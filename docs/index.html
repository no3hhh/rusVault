<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="RusVault">
<meta name="theme-color" content="#0a0a14">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>RusVault</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CSS VARIABLES & RESET
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg: #0a0a14;
  --surface: #12121f;
  --surface2: #1a1a2e;
  --surface3: #222240;
  --accent: #e94560;
  --accent-dim: rgba(233,69,96,0.15);
  --green: #4ecca3;
  --green-dim: rgba(78,204,163,0.15);
  --blue: #5b8def;
  --blue-dim: rgba(91,141,239,0.18);
  --yellow: #f0c040;
  --yellow-dim: rgba(240,192,64,0.18);
  --text: #e8e8f0;
  --muted: #6a6a80;
  --border: #2a2a3e;
  --radius: 14px;
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --tab-h: 64px;
}
[data-theme="light"] {
  --bg: #f5f5fa;
  --surface: #ffffff;
  --surface2: #eeeef4;
  --surface3: #e0e0ea;
  --text: #1a1a2e;
  --muted: #888;
  --border: #d8d8e4;
  --accent-dim: rgba(233,69,96,0.1);
  --green-dim: rgba(78,204,163,0.12);
  --blue-dim: rgba(91,141,239,0.12);
  --yellow-dim: rgba(200,160,40,0.15);
}

*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
html { height:100%; -webkit-text-size-adjust:100%; }
body {
  font-family: 'Outfit', -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  height: 100%;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -webkit-tap-highlight-color: transparent;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   APP SHELL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.app {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
}
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 50;
}
.logo {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent);
  letter-spacing: -0.5px;
}
.logo b { color: var(--green); }
.header-actions { display: flex; gap: 8px; }
.icon-btn {
  width: 36px; height: 36px;
  border: none; border-radius: 10px;
  background: var(--surface2);
  color: var(--muted);
  font-size: 18px;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.15s;
}
.icon-btn:active { transform: scale(0.92); }
.icon-btn.active { color: var(--accent); background: var(--accent-dim); }

/* â”€â”€ View Container â”€â”€â”€ */
.views {
  flex: 1;
  overflow: hidden;
  position: relative;
}
.view {
  position: absolute;
  inset: 0;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding: 16px;
  padding-bottom: calc(var(--tab-h) + var(--safe-bottom) + 20px);
  display: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.view.active { display: block; opacity: 1; }

/* â”€â”€ Tab Bar â”€â”€â”€ */
.tab-bar {
  display: flex;
  background: var(--surface);
  border-top: 1px solid var(--border);
  padding-bottom: var(--safe-bottom);
  flex-shrink: 0;
  z-index: 50;
}
.tab {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  padding: 10px 4px 8px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 10px;
  font-family: inherit;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.15s;
}
.tab svg { width: 22px; height: 22px; }
.tab.active { color: var(--accent); }
.tab:active { transform: scale(0.95); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   READER VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.import-area {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 28px 20px;
  text-align: center;
  margin-bottom: 16px;
}
.import-area h2 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--muted);
}
.import-btns {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
}
.import-btn {
  padding: 10px 16px;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--surface2);
  color: var(--text);
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.15s;
}
.import-btn:active { transform: scale(0.96); background: var(--surface3); }
.import-btn .em { font-size: 16px; }

/* â”€â”€ Text Display Area (ebook mode) â”€â”€â”€ */
.reader-content {
  font-size: 18px;
  line-height: 1.75;
  display: none;
}
.reader-content.has-text {
  display: flex;
  flex-direction: column;
  position: absolute;
  inset: 0;
  padding: 0;
  overflow: hidden;
}
.reader-top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  flex-shrink: 0;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
}
.reader-top-bar .reader-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 8px;
}
.reader-top-bar .close-text {
  color: var(--muted);
  background: none;
  border: none;
  font-size: 22px;
  cursor: pointer;
  padding: 0 4px;
  flex-shrink: 0;
}
.reader-stats-bar {
  display: flex;
  gap: 12px;
  padding: 8px 16px;
  font-size: 11px;
  color: var(--muted);
  flex-shrink: 0;
  background: var(--surface);
}
.reader-stats-bar span b { font-weight: 600; }
.stat-new b { color: var(--blue); }
.stat-saved b { color: var(--yellow); }
.stat-known b { color: var(--green); }
.page-progress-bar {
  height: 3px;
  background: var(--surface2);
  flex-shrink: 0;
}
.page-progress-fill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* â”€â”€ Text body: FIXED height, no scroll â”€â”€â”€ */
#textBody {
  flex: 1;
  overflow: hidden;
  padding: 16px 18px;
  position: relative;
}
#textBody p {
  margin-bottom: 12px;
}

/* â”€â”€ Page navigation bar â”€â”€â”€ */
.page-nav {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  padding-bottom: calc(10px + var(--safe-bottom));
  flex-shrink: 0;
  border-top: 1px solid var(--border);
  background: var(--surface);
  gap: 10px;
}
.page-btn {
  padding: 12px 22px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface2);
  color: var(--text);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 90px;
  text-align: center;
  -webkit-tap-highlight-color: transparent;
}
.page-btn:active { transform: scale(0.96); }
.page-btn:disabled { opacity: 0.25; pointer-events: none; }
.page-btn.next-btn { background: var(--accent); color: #fff; border-color: var(--accent); }
.page-btn.next-btn:active { opacity: 0.85; }
.page-btn.next-btn:disabled { opacity: 0.25; }
.page-info {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--muted);
  text-align: center;
  white-space: nowrap;
}

/* â”€â”€ Page transition animation â”€â”€â”€ */
#textBody.page-turning {
  opacity: 0.3;
  transition: opacity 0.1s;
}
#textBody.page-visible {
  opacity: 1;
  transition: opacity 0.15s;
}

/* â”€â”€ Word tokens â”€â”€â”€ */
.w {
  cursor: pointer;
  border-radius: 3px;
  transition: background 0.12s;
  padding: 1px 1px;
}
.w:active { transform: scale(0.97); }
.w.w-new { color: var(--blue); background: var(--blue-dim); }
.w.w-saved { color: var(--yellow); background: var(--yellow-dim); }
.w.w-known { color: var(--text); opacity: 0.5; }
.w.w-ignored { color: var(--text); opacity: 0.35; }
.w.w-active {
  background: var(--accent-dim) !important;
  color: var(--accent) !important;
  opacity: 1 !important;
  outline: 2px solid var(--accent);
  outline-offset: 1px;
  border-radius: 4px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WORD PANEL (bottom sheet)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.word-panel-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  display: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.word-panel-overlay.show { display: block; opacity: 1; }
.word-panel {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  background: var(--surface);
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  z-index: 101;
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  max-height: 55vh;
  overflow-y: auto;
  padding-bottom: calc(var(--safe-bottom) + 12px);
}
.word-panel.show { transform: translateY(0); }
.panel-handle {
  width: 36px; height: 4px;
  background: var(--border);
  border-radius: 2px;
  margin: 10px auto 0;
}
.panel-body { padding: 16px 20px; }
.panel-word {
  font-size: 26px;
  font-weight: 800;
  color: var(--accent);
  margin-bottom: 2px;
}
.panel-translation {
  font-size: 20px;
  font-weight: 600;
  color: var(--green);
  min-height: 28px;
  margin-bottom: 4px;
}
.panel-alts {
  font-size: 13px;
  color: var(--muted);
  line-height: 1.6;
  margin-bottom: 8px;
}
.panel-alts b { color: var(--accent); font-weight: 600; }
.panel-ctx {
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
  padding: 8px 10px;
  background: var(--surface2);
  border-radius: 8px;
  margin-bottom: 12px;
  max-height: 60px;
  overflow: hidden;
}
.panel-sent {
  font-size: 13px;
  color: var(--blue);
  padding: 8px 10px;
  background: rgba(91,141,239,0.08);
  border-radius: 8px;
  margin-bottom: 12px;
  display: none;
}
.panel-actions {
  display: flex;
  gap: 8px;
}
.panel-btn {
  flex: 1;
  padding: 14px;
  border: none;
  border-radius: 12px;
  font-weight: 700;
  font-size: 14px;
  cursor: pointer;
  font-family: inherit;
  transition: all 0.12s;
}
.panel-btn:active { transform: scale(0.96); }
.btn-save { background: var(--accent); color: #fff; }
.btn-known { background: var(--green-dim); color: var(--green); border: 1px solid rgba(78,204,163,0.3); }
.btn-ignore { background: var(--surface2); color: var(--muted); border: 1px solid var(--border); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VOCAB LIST VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.search-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.search-input {
  flex: 1;
  padding: 12px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  outline: none;
}
.search-input:focus { border-color: var(--accent); }
.search-input::placeholder { color: var(--muted); }
.filter-chips {
  display: flex;
  gap: 6px;
  margin-bottom: 14px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 4px;
}
.chip {
  padding: 7px 14px;
  border-radius: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--muted);
  font-size: 12px;
  font-weight: 500;
  font-family: inherit;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.12s;
}
.chip.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(233,69,96,0.3); }

.word-list { display: flex; flex-direction: column; gap: 6px; }
.word-card {
  display: flex;
  align-items: center;
  padding: 14px 16px;
  background: var(--surface);
  border-radius: var(--radius);
  gap: 12px;
  cursor: pointer;
  transition: background 0.12s;
}
.word-card:active { background: var(--surface2); }
.wc-word {
  font-size: 17px;
  font-weight: 700;
  color: var(--text);
  min-width: 0;
}
.wc-trans {
  flex: 1;
  font-size: 14px;
  color: var(--muted);
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.wc-status {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.wc-status.st-new { background: var(--blue); }
.wc-status.st-saved, .wc-status.st-learning { background: var(--yellow); }
.wc-status.st-known { background: var(--green); }
.wc-status.st-ignored { background: var(--muted); }

.empty-state {
  text-align: center;
  padding: 48px 20px;
  color: var(--muted);
}
.empty-state .big { font-size: 40px; margin-bottom: 12px; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATS VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-bottom: 20px;
}
.stat-card {
  background: var(--surface);
  border-radius: var(--radius);
  padding: 18px 16px;
  text-align: center;
}
.stat-num {
  font-size: 32px;
  font-weight: 800;
  font-family: 'JetBrains Mono', monospace;
}
.stat-num.c-accent { color: var(--accent); }
.stat-num.c-blue { color: var(--blue); }
.stat-num.c-yellow { color: var(--yellow); }
.stat-num.c-green { color: var(--green); }
.stat-label {
  font-size: 12px;
  color: var(--muted);
  margin-top: 4px;
}

.section-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 10px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SETTINGS VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.settings-group {
  background: var(--surface);
  border-radius: var(--radius);
  overflow: hidden;
  margin-bottom: 16px;
}
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
}
.settings-row:last-child { border-bottom: none; }
.settings-label {
  font-size: 15px;
  font-weight: 500;
}
.settings-desc {
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}
.toggle {
  position: relative;
  width: 48px; height: 28px;
  background: var(--surface3);
  border-radius: 14px;
  cursor: pointer;
  transition: background 0.2s;
  border: none;
}
.toggle::after {
  content: '';
  position: absolute;
  width: 22px; height: 22px;
  top: 3px; left: 3px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s;
}
.toggle.on { background: var(--green); }
.toggle.on::after { transform: translateX(20px); }
.action-btn {
  width: 100%;
  padding: 14px;
  border: none;
  border-radius: var(--radius);
  font-weight: 600;
  font-size: 15px;
  cursor: pointer;
  font-family: inherit;
  margin-bottom: 10px;
  transition: all 0.12s;
}
.action-btn:active { transform: scale(0.98); }
.action-btn.primary { background: var(--accent); color: #fff; }
.action-btn.secondary { background: var(--surface); color: var(--text); }
.action-btn.danger { background: rgba(233,69,96,0.15); color: var(--accent); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MODALS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.modal-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 200;
  display: none;
  align-items: flex-end;
  justify-content: center;
}
.modal-overlay.show { display: flex; }
.modal {
  background: var(--surface);
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  padding: 20px;
  padding-bottom: calc(var(--safe-bottom) + 20px);
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
}
.modal-overlay.show .modal { transform: translateY(0); }
.modal h2 {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 16px;
}
.modal textarea {
  width: 100%;
  min-height: 180px;
  padding: 14px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  resize: vertical;
  outline: none;
  margin-bottom: 12px;
}
.modal textarea:focus { border-color: var(--accent); }
.modal input[type="text"], .modal input[type="url"] {
  width: 100%;
  padding: 14px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  outline: none;
  margin-bottom: 12px;
}
.modal input:focus { border-color: var(--accent); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WORD DETAIL MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.detail-word {
  font-size: 28px;
  font-weight: 800;
  color: var(--accent);
}
.detail-trans {
  font-size: 18px;
  color: var(--green);
  margin-bottom: 12px;
}
.detail-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 14px;
}
.detail-badge {
  padding: 4px 10px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
}
.detail-badge.b-status { background: var(--blue-dim); color: var(--blue); }
.detail-badge.b-encounters { background: var(--yellow-dim); color: var(--yellow); }
.detail-ctx-list {
  margin-top: 12px;
}
.detail-ctx-item {
  font-size: 13px;
  color: var(--muted);
  padding: 8px;
  background: var(--surface2);
  border-radius: 8px;
  margin-bottom: 6px;
  font-style: italic;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UTILITY
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.hidden { display: none !important; }
input[type="file"] { display: none; }

/* Loading spinner */
.spinner {
  display: inline-block;
  width: 18px; height: 18px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Toast */
.toast {
  position: fixed;
  bottom: calc(var(--tab-h) + var(--safe-bottom) + 12px);
  left: 50%; transform: translateX(-50%) translateY(80px);
  background: var(--surface2);
  color: var(--green);
  border: 1px solid rgba(78,204,163,0.3);
  padding: 10px 20px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  z-index: 300;
  opacity: 0;
  transition: all 0.3s;
  pointer-events: none;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

/* Scrollbar */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* Lesson cards */
.lesson-card { background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:12px 14px;margin-bottom:10px;cursor:pointer;transition:border-color .2s; }
.lesson-card:active { border-color:var(--accent); }
.lesson-card-title { font-weight:600;font-size:14px;margin-bottom:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; }
.lesson-card-meta { font-size:11px;color:var(--muted);display:flex;justify-content:space-between;align-items:center; }
.lesson-card-progress { display:flex;gap:8px;font-size:11px;margin-top:6px; }
.lesson-card-progress span { display:flex;align-items:center;gap:2px; }
.lesson-card-bar { height:4px;border-radius:2px;background:var(--surface2);margin-top:6px;overflow:hidden; }
.lesson-card-bar-fill { height:100%;border-radius:2px;transition:width .3s; }
.lesson-card-actions { display:flex;gap:6px;margin-top:8px; }
.lesson-card-actions button { flex:1;padding:6px;border:none;border-radius:8px;font-size:12px;font-weight:600;cursor:pointer; }
.lesson-btn-resume { background:var(--accent);color:#fff; }
.lesson-btn-delete { background:var(--surface2);color:var(--muted); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FLASHCARD MODE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.fc-setup { padding: 4px 0; }
.fc-setup-title { font-size: 16px; font-weight: 700; margin-bottom: 14px; display: flex; align-items: center; gap: 8px; }
.fc-option-group { background: var(--surface); border-radius: var(--radius); padding: 14px 16px; margin-bottom: 12px; }
.fc-option-label { font-size: 13px; font-weight: 600; color: var(--muted); margin-bottom: 8px; }
.fc-option-row { display: flex; gap: 6px; flex-wrap: wrap; }
.fc-chip {
  padding: 8px 14px; border-radius: 20px; background: var(--surface2); border: 1px solid var(--border);
  color: var(--muted); font-size: 13px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.12s;
}
.fc-chip.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(233,69,96,0.3); }
.fc-start-btn {
  width: 100%; padding: 16px; border: none; border-radius: var(--radius); background: var(--accent); color: #fff;
  font-size: 16px; font-weight: 700; cursor: pointer; font-family: inherit; margin-top: 8px; transition: all 0.12s;
}
.fc-start-btn:active { transform: scale(0.98); }
.fc-start-btn:disabled { opacity: 0.4; }

/* Flashcard session */
.fc-session {
  display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 200; background: var(--bg);
  flex-direction: column; padding: 0;
}
.fc-session.active { display: flex; }
.fc-session-header {
  display: flex; align-items: center; justify-content: space-between; padding: 12px 16px;
  padding-top: calc(12px + var(--safe-top));
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.fc-progress-text { font-family: 'JetBrains Mono'; font-size: 13px; color: var(--muted); }
.fc-close { background: none; border: none; color: var(--muted); font-size: 22px; cursor: pointer; }
.fc-progress-bar { height: 3px; background: var(--surface2); flex-shrink: 0; }
.fc-progress-fill { height: 100%; background: var(--green); transition: width 0.3s; }

.fc-card-area {
  flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; overflow: hidden;
}
.fc-card {
  width: 100%; max-width: 360px; background: var(--surface); border-radius: 20px;
  padding: 32px 24px; text-align: center; cursor: pointer;
  box-shadow: 0 4px 24px rgba(0,0,0,0.15); transition: transform 0.15s;
  min-height: 200px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px;
}
.fc-card:active { transform: scale(0.98); }
.fc-card-word { font-size: 32px; font-weight: 800; color: var(--accent); }
.fc-card-hint { font-size: 13px; color: var(--muted); }
.fc-card-answer { font-size: 22px; font-weight: 600; color: var(--green); margin-top: 8px; }
.fc-card-ctx { font-size: 12px; color: var(--muted); font-style: italic; margin-top: 4px; max-width: 280px; }
.fc-speak-btn { background: none; border: none; font-size: 28px; cursor: pointer; margin-top: 4px; }

.fc-buttons {
  display: flex; gap: 8px; padding: 12px 16px; padding-bottom: calc(12px + var(--safe-bottom));
  flex-shrink: 0; border-top: 1px solid var(--border); background: var(--surface);
}
.fc-btn {
  flex: 1; padding: 14px 8px; border: none; border-radius: 12px;
  font-weight: 700; font-size: 13px; cursor: pointer; font-family: inherit; transition: all 0.12s;
  display: flex; flex-direction: column; align-items: center; gap: 2px;
}
.fc-btn:active { transform: scale(0.96); }
.fc-btn-again { background: rgba(233,69,96,0.15); color: var(--accent); }
.fc-btn-hard { background: var(--yellow-dim); color: var(--yellow); }
.fc-btn-good { background: var(--green-dim); color: var(--green); }
.fc-btn-easy { background: var(--blue-dim); color: var(--blue); }
.fc-btn span { font-size: 10px; font-weight: 400; opacity: 0.7; }
.fc-result { text-align: center; padding: 40px 20px; }
.fc-result-big { font-size: 48px; margin-bottom: 12px; }
.fc-result-text { font-size: 18px; font-weight: 600; margin-bottom: 6px; }
.fc-result-sub { font-size: 14px; color: var(--muted); }
</style>
</head>
<body>

<div class="app">
  <!-- â•â• Header â•â• -->
  <div class="header">
    <div class="logo">Rus<b>Vault</b></div>
    <div class="header-actions">
      <button class="icon-btn" id="btnTheme" title="Toggle theme">â—‘</button>
    </div>
  </div>

  <!-- â•â• Views â•â• -->
  <div class="views">

    <!-- â”€â”€ READER â”€â”€ -->
    <div class="view active" id="viewReader">
      <div id="importArea" class="import-area">
        <h2>Import Russian text</h2>
        <div class="import-btns">
          <button class="import-btn" id="btnPaste"><span class="em">ğŸ“„</span> Paste text</button>
          <button class="import-btn" id="btnFile"><span class="em">ğŸ“‚</span> .txt file</button>
          <button class="import-btn" id="btnPdf"><span class="em">ğŸ“•</span> PDF</button>
          <button class="import-btn" id="btnYT"><span class="em">ğŸ¥</span> YouTube</button>
        </div>
        <input type="file" id="fileInput" accept=".txt">
        <input type="file" id="pdfInput" accept=".pdf">
        <div id="lessonList" style="margin-top:20px;"></div>
      </div>

      <div id="readerContent" class="reader-content">
        <div class="reader-top-bar">
          <span class="reader-label" id="readerLabel">Text</span>
          <span class="page-info" id="pageInfo">1 / 1</span>
          <button class="close-text" id="btnCloseText">Ã—</button>
        </div>
        <div class="reader-stats-bar">
          <span class="stat-new">ğŸ”µ <b id="countNew">0</b></span>
          <span class="stat-saved">ğŸŸ¡ <b id="countSaved">0</b></span>
          <span class="stat-known">âšª <b id="countKnown">0</b></span>
        </div>
        <div class="page-progress-bar"><div class="page-progress-fill" id="pageProgressFill" style="width:0%"></div></div>
        <div id="textBody"></div>
        <div class="page-nav">
          <button class="page-btn" id="btnPrevPage" disabled>â† PrÃ©c</button>
          <button class="page-btn next-btn" id="btnNextPage">Suiv â†’</button>
        </div>
      </div>
    </div>

    <!-- â”€â”€ VOCAB â”€â”€ -->
    <div class="view" id="viewVocab">
      <!-- Vocab mode toggle -->
      <div style="display:flex;gap:8px;margin-bottom:12px;">
        <button class="chip active" id="btnVocabList" style="flex:1;text-align:center;padding:10px;">ğŸ“– Liste</button>
        <button class="chip" id="btnVocabFlash" style="flex:1;text-align:center;padding:10px;">ğŸƒ Flashcards</button>
      </div>

      <!-- LIST MODE -->
      <div id="vocabListMode">
        <div class="search-bar">
          <input class="search-input" id="vocabSearch" placeholder="Search wordsâ€¦" type="text" autocomplete="off" autocapitalize="off" spellcheck="false">
        </div>
        <div class="filter-chips" id="filterChips">
          <button class="chip active" data-filter="all">All</button>
          <button class="chip" data-filter="new">New</button>
          <button class="chip" data-filter="saved">Saved</button>
          <button class="chip" data-filter="learning">Learning</button>
          <button class="chip" data-filter="known">Known</button>
          <button class="chip" data-filter="ignored">Ignored</button>
        </div>
        <div class="word-list" id="wordList"></div>
      </div>

      <!-- FLASHCARD SETUP -->
      <div id="vocabFlashMode" style="display:none;">
        <div class="fc-setup">
          <div class="fc-option-group">
            <div class="fc-option-label">ğŸ“š Source</div>
            <div class="fc-option-row" id="fcLessonChips">
              <button class="fc-chip active" data-lesson="all">Tout</button>
              <button class="fc-chip" data-lesson="saved">SauvÃ©s</button>
              <button class="fc-chip" data-lesson="due">Ã€ rÃ©viser</button>
              <button class="fc-chip" data-lesson="known">Connus</button>
            </div>
          </div>
          <div class="fc-option-group">
            <div class="fc-option-label">ğŸ”¢ Nombre de cartes</div>
            <div class="fc-option-row" id="fcCountChips">
              <button class="fc-chip" data-count="10">10</button>
              <button class="fc-chip active" data-count="20">20</button>
              <button class="fc-chip" data-count="50">50</button>
              <button class="fc-chip" data-count="all">Tout</button>
            </div>
          </div>
          <div id="fcWordCount" style="text-align:center;font-size:13px;color:var(--muted);margin:8px 0;"></div>
          <button class="fc-start-btn" id="fcStartBtn">â–¶ Commencer la rÃ©vision</button>
        </div>
      </div>

      </div>
    </div>

    <!-- â”€â”€ STATS â”€â”€ -->
    <div class="view" id="viewStats">
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-num c-accent" id="statTotal">0</div>
          <div class="stat-label">Total Words</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-blue" id="statNew">0</div>
          <div class="stat-label">New</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-yellow" id="statLearning">0</div>
          <div class="stat-label">Learning</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-green" id="statKnown">0</div>
          <div class="stat-label">Known</div>
        </div>
      </div>
      <div class="section-title">Vocabulary Breakdown</div>
      <div id="progressBar" style="height:12px;border-radius:6px;background:var(--surface);overflow:hidden;margin-bottom:24px;">
        <div style="display:flex;height:100%;">
          <div id="prgNew" style="background:var(--blue);transition:width 0.3s"></div>
          <div id="prgLearning" style="background:var(--yellow);transition:width 0.3s"></div>
          <div id="prgKnown" style="background:var(--green);transition:width 0.3s"></div>
        </div>
      </div>
      <div class="section-title">Recent Activity</div>
      <div id="activityList" style="display:flex;flex-direction:column;gap:6px;"></div>
    </div>

    <!-- â”€â”€ SETTINGS â”€â”€ -->
    <div class="view" id="viewSettings">
      <div class="section-title">Display</div>
      <div class="settings-group">
        <div class="settings-row">
          <div>
            <div class="settings-label">Dark Mode</div>
            <div class="settings-desc">Switch between dark and light</div>
          </div>
          <button class="toggle on" id="toggleDark"></button>
        </div>
        <div class="settings-row">
          <div>
            <div class="settings-label">Font Size</div>
            <div class="settings-desc">Reader text size</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="icon-btn" id="fontMinus" style="width:32px;height:32px;font-size:16px;">âˆ’</button>
            <span id="fontSizeLabel" style="font-family:'JetBrains Mono';font-size:13px;min-width:32px;text-align:center;">18</span>
            <button class="icon-btn" id="fontPlus" style="width:32px;height:32px;font-size:16px;">+</button>
          </div>
        </div>
      </div>

      <div class="section-title">YouTube (optionnel)</div>
      <div style="font-size:12px;color:var(--muted);margin-bottom:8px;line-height:1.5;">
        Si Invidious ne fonctionne pas, tu peux dÃ©ployer un backend Vercel comme fallback.
      </div>
      <input type="url" id="vercelUrlInput" placeholder="https://rusvault-api.vercel.app" style="width:100%;padding:12px;background:var(--surface);border:1px solid var(--border);border-radius:10px;color:var(--text);font-family:inherit;font-size:14px;outline:none;margin-bottom:8px;">
      <button class="action-btn secondary" id="btnSaveVercel">ğŸ’¾ Sauvegarder URL Vercel</button>

      <div class="section-title">Data</div>
      <button class="action-btn secondary" id="btnExport">ğŸ“¤ Export Database (JSON)</button>
      <button class="action-btn secondary" id="btnImport">ğŸ“¥ Import Database (JSON)</button>
      <input type="file" id="importDbInput" accept=".json">
      <button class="action-btn danger" id="btnClear">ğŸ—‘ Clear All Data</button>
      <button class="action-btn secondary" id="btnResetSW" style="margin-top:4px;">ğŸ”„ Reset Service Worker (si bugs)</button>

      <div style="margin-top:24px;text-align:center;color:var(--muted);font-size:12px;">
        RusVault PWA v1.0<br>
        Offline-first Â· No cloud Â· Your data stays local
      </div>
    </div>
  </div>

  <!-- â•â• Tab Bar â•â• -->
  <div class="tab-bar">
    <button class="tab active" data-view="viewReader">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
      Read
    </button>
    <button class="tab" data-view="viewVocab">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
      Vocab
    </button>
    <button class="tab" data-view="viewStats">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/></svg>
      Stats
    </button>
    <button class="tab" data-view="viewSettings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
      Settings
    </button>
  </div>
</div>

<!-- â•â• Flashcard Session (fullscreen overlay) â•â• -->
<div class="fc-session" id="fcSession">
  <div class="fc-session-header">
    <span class="fc-progress-text" id="fcProgressText">0 / 0</span>
    <button class="fc-close" id="fcCloseBtn">âœ•</button>
  </div>
  <div class="fc-progress-bar"><div class="fc-progress-fill" id="fcProgressFill" style="width:0%"></div></div>
  <div class="fc-card-area" id="fcCardArea">
    <div class="fc-card" id="fcCard">
      <div class="fc-card-word" id="fcWord">â€”</div>
      <button class="fc-speak-btn" id="fcSpeak">ğŸ”Š</button>
      <div class="fc-card-hint" id="fcHint">Tap pour rÃ©vÃ©ler</div>
      <div class="fc-card-answer" id="fcAnswer" style="display:none;">â€”</div>
      <div class="fc-card-ctx" id="fcCtx" style="display:none;"></div>
    </div>
  </div>
  <div class="fc-buttons" id="fcButtons" style="display:none;">
    <button class="fc-btn fc-btn-again" data-grade="0">OubliÃ©<span>&lt;1m</span></button>
    <button class="fc-btn fc-btn-hard" data-grade="1">Difficile<span id="fcHardInt">1j</span></button>
    <button class="fc-btn fc-btn-good" data-grade="2">Bien<span id="fcGoodInt">3j</span></button>
    <button class="fc-btn fc-btn-easy" data-grade="3">Facile<span id="fcEasyInt">7j</span></button>
  </div>
</div>

<!-- â•â• Word Panel (bottom sheet) â•â• -->
<div class="word-panel-overlay" id="panelOverlay"></div>
<div class="word-panel" id="wordPanel">
  <div class="panel-handle"></div>
  <div class="panel-body">
    <div style="display:flex;align-items:center;gap:10px;">
      <div class="panel-word" id="panelWord" style="flex:1;">â€”</div>
      <button id="panelSpeak" style="background:none;border:none;font-size:24px;cursor:pointer;padding:4px;">ğŸ”Š</button>
    </div>
    <div class="panel-translation" id="panelTrans">â³</div>
    <div class="panel-alts" id="panelAlts"></div>
    <div class="panel-ctx" id="panelCtx"></div>
    <div class="panel-sent" id="panelSent"></div>
    <div class="panel-actions">
      <button class="panel-btn btn-save" id="panelSave">ğŸ’¾ Save</button>
      <button class="panel-btn btn-known" id="panelKnown">âœ“ Known</button>
      <button class="panel-btn btn-ignore" id="panelIgnore">âœ— Ignore</button>
    </div>
  </div>
</div>

<!-- â•â• Paste Modal â•â• -->
<div class="modal-overlay" id="pasteModal">
  <div class="modal">
    <h2>ğŸ“„ Paste Russian text</h2>
    <textarea id="pasteInput" placeholder="Ğ’ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚ ÑÑĞ´Ğ°â€¦"></textarea>
    <input type="text" id="pasteTitle" placeholder="Title (optional)">
    <button class="action-btn primary" id="pasteSubmit">Open Text</button>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('pasteModal')">Cancel</button>
  </div>
</div>

<!-- â•â• YouTube Modal â•â• -->
<div class="modal-overlay" id="ytModal">
  <div class="modal">
    <h2>ğŸ¥ YouTube â†’ RusVault</h2>

    <div style="margin-bottom:14px;">
      <div style="font-size:14px;font-weight:600;margin-bottom:6px;">Option 1 â€” Colle l'URL</div>
      <input type="url" id="ytUrl" placeholder="https://youtube.com/watch?v=â€¦">
      <button class="action-btn primary" id="ytSubmitUrl" style="margin-bottom:0;">ğŸ” Chercher les sous-titres</button>
      <div id="ytStatus" style="font-size:12px;color:var(--muted);text-align:center;min-height:18px;margin-top:6px;"></div>
    </div>

    <div style="background:var(--surface2);border-radius:10px;padding:10px 12px;margin-bottom:10px;line-height:1.5;">
      <div style="font-size:13px;font-weight:600;margin-bottom:4px;">Option 2 â€” Copier-coller manuel</div>
      <div style="font-size:12px;color:var(--muted);">
        YouTube â†’ <b>â‹¯</b> sous la vidÃ©o â†’ <b>Afficher la transcription</b> â†’ Copier tout â†’ Coller ici â†“
      </div>
    </div>

    <textarea id="ytText" placeholder="Colle le transcript russe iciâ€¦" style="min-height:120px;"></textarea>
    <input type="text" id="ytTitle" placeholder="Titre (optionnel)">
    <button class="action-btn primary" id="ytSubmitText">ğŸ“„ Importer le texte</button>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('ytModal')">Annuler</button>
  </div>
</div>

<!-- â•â• Word Detail Modal â•â• -->
<div class="modal-overlay" id="detailModal">
  <div class="modal">
    <div class="detail-word" id="detailWord">â€”</div>
    <div class="detail-trans" id="detailTrans">â€”</div>
    <div class="detail-meta" id="detailMeta"></div>
    <div class="detail-ctx-list" id="detailContexts"></div>
    <div style="display:flex;gap:8px;margin-top:16px;">
      <button class="panel-btn btn-known" id="detailKnown" style="flex:1;">âœ“ Mark Known</button>
      <button class="panel-btn btn-ignore" id="detailDelete" style="flex:1;background:var(--accent-dim);color:var(--accent);">ğŸ—‘ Delete</button>
    </div>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('detailModal')">Close</button>
  </div>
</div>

<!-- â•â• Toast â•â• -->
<div class="toast" id="toast"></div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RUSVAULT PWA â€” Core Application Logic
   IndexedDB + Offline-first + LingQ-style reader
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

(function() {
'use strict';

// â”€â”€ Constants â”€â”€
const RU_WORD = /([Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]+)/g;
const RU_TEST = /[Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]/;

// Safari-compatible fetch timeout (no AbortController â€” uses Promise.race)
function fetchWithTimeout(url, opts, ms) {
  var timeout = new Promise(function(_, reject) {
    setTimeout(function() { reject(new Error('timeout')); }, ms || 8000);
  });
  return Promise.race([fetch(url, opts || {}), timeout]);
}
const DB_NAME = 'rusvault';
const DB_VERSION = 2;

// â”€â”€ State â”€â”€
let db = null;
let wordCache = new Map();
let currentWord = null;
let currentCtx = '';
let currentLessonId = null;
let settings = {
  darkMode: true,
  fontSize: 18
};

// â”€â”€ Ebook pagination state â”€â”€
let allChunks = [];           // text split into sentences/small chunks
let pages = [];               // array of arrays: each sub-array = chunk indices for that page
let currentPage = 0;

// â”€â”€ Preload TTS voices â”€â”€
let cachedRuVoice = null;
function preloadVoices() {
  if (!('speechSynthesis' in window)) return;
  var voices = speechSynthesis.getVoices();
  if (voices.length > 0) {
    cachedRuVoice = voices.find(function(v) { return v.lang && v.lang.startsWith('ru'); }) || null;
  }
}
preloadVoices();
if ('speechSynthesis' in window && speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.onvoiceschanged = preloadVoices;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INDEXEDDB
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;

      if (!db.objectStoreNames.contains('words')) {
        const ws = db.createObjectStore('words', { keyPath: 'id', autoIncrement: true });
        ws.createIndex('word', 'word', { unique: false });
        ws.createIndex('wordLower', 'wordLower', { unique: false });
        ws.createIndex('status', 'status', { unique: false });
        ws.createIndex('createdAt', 'createdAt', { unique: false });
      }

      if (!db.objectStoreNames.contains('sources')) {
        const ss = db.createObjectStore('sources', { keyPath: 'id', autoIncrement: true });
        ss.createIndex('type', 'type', { unique: false });
      }

      if (!db.objectStoreNames.contains('lessons')) {
        const ls = db.createObjectStore('lessons', { keyPath: 'id', autoIncrement: true });
        ls.createIndex('createdAt', 'createdAt', { unique: false });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}

function tx(storeName, mode = 'readonly') {
  return db.transaction(storeName, mode).objectStore(storeName);
}

function dbGet(store, key) {
  return new Promise((res, rej) => {
    const r = tx(store).get(key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbGetAll(store) {
  return new Promise((res, rej) => {
    const r = tx(store).getAll();
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbPut(store, data) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').put(data);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbAdd(store, data) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').add(data);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbDelete(store, key) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').delete(key);
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}

function dbClear(store) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').clear();
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}

function dbFindByIndex(store, indexName, value) {
  return new Promise((res, rej) => {
    const r = tx(store).index(indexName).getAll(value);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

// â”€â”€ Load word cache (all words into memory for fast highlighting) â”€â”€
async function loadWordCache() {
  const all = await dbGetAll('words');
  wordCache.clear();
  for (const w of all) {
    wordCache.set(w.wordLower, w);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const tabs = document.querySelectorAll('.tab');
const views = document.querySelectorAll('.view');

tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    const target = tab.dataset.view;
    tabs.forEach(t => t.classList.remove('active'));
    views.forEach(v => v.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(target).classList.add('active');

    if (target === 'viewReader') renderLessonList();
    if (target === 'viewVocab') renderVocabList();
    if (target === 'viewStats') renderStats();
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THEME & SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function loadSettings() {
  try {
    const s = localStorage.getItem('rv_settings');
    if (s) settings = { ...settings, ...JSON.parse(s) };
  } catch (e) {}
  applySettings();
}

function saveSettings() {
  localStorage.setItem('rv_settings', JSON.stringify(settings));
}

function applySettings() {
  document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light');
  document.getElementById('toggleDark').classList.toggle('on', settings.darkMode);
  document.getElementById('fontSizeLabel').textContent = settings.fontSize;
}

document.getElementById('btnTheme').addEventListener('click', () => {
  settings.darkMode = !settings.darkMode;
  applySettings(); saveSettings();
});

document.getElementById('toggleDark').addEventListener('click', () => {
  settings.darkMode = !settings.darkMode;
  applySettings(); saveSettings();
});

document.getElementById('fontMinus').addEventListener('click', () => {
  if (settings.fontSize > 12) { settings.fontSize -= 2; applySettings(); saveSettings(); updateReaderFont(); }
});
document.getElementById('fontPlus').addEventListener('click', () => {
  if (settings.fontSize < 30) { settings.fontSize += 2; applySettings(); saveSettings(); updateReaderFont(); }
});

function updateReaderFont() {
  var el = document.getElementById('textBody');
  if (el) {
    el.style.fontSize = settings.fontSize + 'px';
    // Re-paginate with new font size if in ebook mode
    if (allChunks.length > 0) {
      var lessonText = allChunks.join('\n');
      buildPages(lessonText);
      if (currentPage >= pages.length) currentPage = pages.length - 1;
      showPage(currentPage);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  READER â€” Import & Display
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Paste â”€â”€
document.getElementById('btnPaste').addEventListener('click', () => openModal('pasteModal'));
document.getElementById('pasteSubmit').addEventListener('click', () => {
  const text = document.getElementById('pasteInput').value.trim();
  if (!text) return;
  const title = document.getElementById('pasteTitle').value.trim() || 'Pasted text';
  currentLessonId = null;
  loadText(text, title);
  closeModal('pasteModal');
  document.getElementById('pasteInput').value = '';
  document.getElementById('pasteTitle').value = '';
});

// â”€â”€ File â”€â”€
document.getElementById('btnFile').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});
document.getElementById('fileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    currentLessonId = null;
    loadText(ev.target.result, file.name);
  };
  reader.readAsText(file);
  e.target.value = '';
});

// â”€â”€ PDF â”€â”€
document.getElementById('btnPdf').addEventListener('click', () => {
  document.getElementById('pdfInput').click();
});
document.getElementById('pdfInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  showToast('ğŸ“• Extraction du PDFâ€¦');

  try {
    var arrayBuffer = await file.arrayBuffer();
    if (typeof pdfjsLib === 'undefined') {
      showToast('âŒ PDF.js non chargÃ©. VÃ©rifie ta connexion.');
      return;
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    var pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    var fullText = '';

    for (var p = 1; p <= pdf.numPages; p++) {
      var page = await pdf.getPage(p);
      var content = await page.getTextContent();
      var pageText = content.items.map(function(item) { return item.str; }).join(' ');
      fullText += pageText + '\n';
    }

    fullText = fullText.trim();
    if (fullText.length < 10) {
      showToast('âŒ Pas de texte trouvÃ© dans le PDF');
      return;
    }

    currentLessonId = null;
    loadText(fullText, file.name.replace('.pdf', ''));
    showToast('âœ“ PDF importÃ© ! (' + pdf.numPages + ' pages)');
  } catch (err) {
    console.error('[PDF]', err);
    showToast('âŒ Erreur PDF: ' + err.message);
  }
  e.target.value = '';
});

// â”€â”€ YouTube â”€â”€
document.getElementById('btnYT').addEventListener('click', function() { openModal('ytModal'); });

// Option 1: Auto URL
document.getElementById('ytSubmitUrl').addEventListener('click', async function() {
  var url = document.getElementById('ytUrl').value.trim();
  var status = document.getElementById('ytStatus');
  if (!url) { showToast('Entre une URL YouTube'); return; }

  var videoId = extractYTId(url);
  if (!videoId) { showToast('âŒ URL invalide'); return; }

  status.textContent = 'â³ Recherche des sous-titres russesâ€¦';

  try {
    var subs = await fetchYTSubtitles(videoId);
    if (subs && subs.length > 20) {
      var title = document.getElementById('ytTitle').value.trim() || 'YouTube: ' + videoId;
      currentLessonId = null;
      loadText(subs, title);
      closeModal('ytModal');
      document.getElementById('ytUrl').value = '';
      document.getElementById('ytTitle').value = '';
      status.textContent = '';
      showToast('âœ“ Sous-titres importÃ©s !');
    } else {
      status.textContent = 'âš ï¸ Pas de sous-titres russes trouvÃ©s. Essaie le copier-coller.';
    }
  } catch (err) {
    console.error('[RusVault YT]', err);
    status.textContent = 'âš ï¸ ' + (err.message || 'Ã‰chec') + '. Essaie le copier-coller.';
  }
});

// Option 2: Paste
document.getElementById('ytSubmitText').addEventListener('click', function() {
  var text = document.getElementById('ytText').value.trim();
  if (!text) { showToast('Colle du texte d\'abord'); return; }
  var title = document.getElementById('ytTitle').value.trim() || 'YouTube transcript';
  var cleaned = cleanTranscript(text);
  if (cleaned.length < 10) { showToast('Pas assez de texte'); return; }
  currentLessonId = null;
  loadText(cleaned, title);
  closeModal('ytModal');
  document.getElementById('ytText').value = '';
  document.getElementById('ytUrl').value = '';
  document.getElementById('ytTitle').value = '';
  document.getElementById('ytStatus').textContent = '';
});

function extractYTId(url) {
  var m = url.match(/(?:v=|youtu\.be\/|\/shorts\/)([a-zA-Z0-9_-]{11})/);
  return m ? m[1] : null;
}

async function fetchYTSubtitles(videoId) {
  var status = document.getElementById('ytStatus');

  // List of public Invidious instances with CORS enabled
  var instances = [
    'https://inv.nadeko.net',
    'https://invidious.nerdvpn.de',
    'https://invidious.jing.rocks',
    'https://invidious.privacyredirect.com',
    'https://invidious.protokolla.fi',
    'https://iv.datura.network',
    'https://invidious.perennialte.ch',
    'https://yt.drgnz.club'
  ];

  // Try fetching the instance list dynamically for freshness
  try {
    var listResp = await fetchWithTimeout('https://api.invidious.io/instances.json?sort_by=health', {}, 5000);
    if (listResp.ok) {
      var allInstances = await listResp.json();
      var fresh = allInstances
        .filter(function(entry) {
          var info = entry[1];
          return info && info.type === 'https' && info.api === true && info.cors === true;
        })
        .map(function(entry) { return entry[1].uri; })
        .slice(0, 12);
      if (fresh.length >= 3) instances = fresh;
    }
  } catch (e) { /* use hardcoded fallback */ }

  // Shuffle to spread load
  for (var s = instances.length - 1; s > 0; s--) {
    var r = Math.floor(Math.random() * (s + 1));
    var tmp = instances[s]; instances[s] = instances[r]; instances[r] = tmp;
  }

  for (var i = 0; i < instances.length; i++) {
    var base = instances[i];
    status.textContent = 'ğŸ” Tentative ' + (i + 1) + '/' + instances.length + 'â€¦';

    try {
      // Step 1: List available captions
      var listUrl = base + '/api/v1/captions/' + videoId;
      var capResp = await fetchWithTimeout(listUrl, {}, 6000);
      if (!capResp.ok) continue;
      var listData = await capResp.json();
      var captions = listData.captions || [];

      // Find Russian caption
      var target = null;
      for (var c = 0; c < captions.length; c++) {
        var cap = captions[c];
        var lc = (cap.language_code || cap.languageCode || '').toLowerCase();
        if (lc === 'ru' || lc.startsWith('ru-')) {
          target = cap;
          break;
        }
      }

      if (!target) {
        // Try auto-generated (label often contains "auto" or "Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸")
        for (var c2 = 0; c2 < captions.length; c2++) {
          var label = (captions[c2].label || '').toLowerCase();
          if (label.indexOf('Ñ€ÑƒÑÑĞº') !== -1 || label.indexOf('russian') !== -1) {
            target = captions[c2];
            break;
          }
        }
      }

      if (!target) continue;

      // Step 2: Fetch the actual subtitle text
      var subUrl = base + target.url;
      // Force VTT format
      if (subUrl.indexOf('?') === -1) subUrl += '?format=vtt';
      else subUrl += '&format=vtt';

      var subResp = await fetchWithTimeout(subUrl, {}, 8000);
      if (!subResp.ok) continue;
      var subText = await subResp.text();

      // Parse VTT to plain text
      var parsed = parseVTT(subText);
      if (parsed && parsed.length > 20) {
        status.textContent = 'ğŸ“ Sous-titres trouvÃ©s !';
        return parsed;
      }
    } catch (e) {
      continue;
    }
  }

  // Fallback: try Vercel backend if configured
  var vercelUrl = localStorage.getItem('rusvault_vercel_url');
  if (vercelUrl) {
    try {
      status.textContent = 'ğŸ”„ Tentative via backend Vercelâ€¦';
      vercelUrl = vercelUrl.replace(/\/+$/, '');
      var vResp = await fetchWithTimeout(vercelUrl + '/api/subs?v=' + videoId + '&lang=ru', {}, 25000);
      if (vResp.ok) {
        var vData = await vResp.json();
        if (vData.ok && vData.text && vData.text.length > 20) {
          status.textContent = 'ğŸ“ TrouvÃ© via Vercel !';
          return vData.text;
        }
      }
    } catch (e) { /* Vercel also failed */ }
  }

  throw new Error('Aucune instance n\'a pu rÃ©cupÃ©rer les sous-titres');
}

// Parse VTT subtitle format to plain text
function parseVTT(vtt) {
  return vtt
    .split('\n')
    .filter(function(line) {
      // Remove timestamps, headers, empty lines
      if (!line.trim()) return false;
      if (line.indexOf('-->') !== -1) return false;
      if (line.match(/^WEBVTT/)) return false;
      if (line.match(/^Kind:|^Language:/)) return false;
      if (line.match(/^\d+$/)) return false;
      return true;
    })
    .map(function(line) {
      // Remove VTT tags like <c>, </c>, timestamps in cues
      return line.replace(/<[^>]+>/g, '').replace(/&nbsp;/g, ' ').trim();
    })
    .filter(function(line) { return line.length > 0; })
    // Remove consecutive duplicate lines (common in auto-subs)
    .filter(function(line, idx, arr) { return idx === 0 || line !== arr[idx - 1]; })
    .join(' ')
    .replace(/\s{2,}/g, ' ')
    .trim();
}

function cleanTranscript(text) {
  return text
    .replace(/\d{1,2}:\d{2}(:\d{2})?/g, '')
    .replace(/\[.*?\]/g, '')
    .replace(/\n{2,}/g, '\n')
    .trim()
    .split('\n')
    .map(function(l) { return l.trim(); })
    .filter(function(l) { return l.length > 0; })
    .join(' ')
    .replace(/\s{2,}/g, ' ');
}

// â”€â”€ Load text into reader â”€â”€
async function loadText(text, title, startPage) {
  document.getElementById('importArea').style.display = 'none';
  const rc = document.getElementById('readerContent');
  rc.classList.add('has-text');
  document.getElementById('readerLabel').textContent = title || 'Text';

  buildPages(text);
  currentPage = Math.min(startPage || 0, pages.length - 1);
  if (currentPage < 0) currentPage = 0;
  showPage(currentPage);

  // Save as lesson
  if (!currentLessonId) {
    var now = new Date().toISOString();
    var lesson = {
      title: title || 'Text',
      text: text,
      createdAt: now,
      lastOpenedAt: now,
      currentPage: 0
    };
    var id = await dbAdd('lessons', lesson);
    currentLessonId = id;
  } else {
    try {
      var les = await dbGet('lessons', currentLessonId);
      if (les) {
        les.lastOpenedAt = new Date().toISOString();
        await dbPut('lessons', les);
      }
    } catch (e) {}
  }

  // Setup swipe gestures
  setupSwipe();
}

function openLesson(lesson) {
  currentLessonId = lesson.id;
  loadText(lesson.text, lesson.title, lesson.currentPage || 0);
}

async function deleteLesson(id) {
  return new Promise(function(resolve, reject) {
    var t = db.transaction('lessons', 'readwrite');
    var req = t.objectStore('lessons').delete(id);
    req.onsuccess = function() { resolve(); };
    req.onerror = function(e) { reject(e.target.error); };
  });
}

async function renderLessonList() {
  var container = document.getElementById('lessonList');
  var lessons = await dbGetAll('lessons');
  
  if (lessons.length === 0) {
    container.innerHTML = '';
    return;
  }

  // Sort by lastOpenedAt descending
  lessons.sort(function(a, b) {
    return (b.lastOpenedAt || b.createdAt).localeCompare(a.lastOpenedAt || a.createdAt);
  });

  var html = '<div style="font-size:14px;font-weight:700;margin-bottom:10px;">ğŸ“š Mes leÃ§ons</div>';

  for (var i = 0; i < lessons.length; i++) {
    var l = lessons[i];
    // Count word stats for this lesson
    var words = l.text.match(RU_WORD) || [];
    var uniqueWords = {};
    for (var j = 0; j < words.length; j++) {
      uniqueWords[words[j].toLowerCase()] = true;
    }
    var unique = Object.keys(uniqueWords);
    var newC = 0, knownC = 0, savedC = 0;
    for (var k = 0; k < unique.length; k++) {
      var cached = wordCache.get(unique[k]);
      if (!cached) newC++;
      else if (cached.status === 'known' || cached.status === 'ignored') knownC++;
      else savedC++;
    }
    var total = unique.length || 1;
    var pctKnown = Math.round((knownC / total) * 100);
    var pctSaved = Math.round((savedC / total) * 100);

    var dateStr = '';
    try {
      var d = new Date(l.lastOpenedAt || l.createdAt);
      dateStr = d.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' });
    } catch (e) {}

    html += '<div class="lesson-card" data-lesson-id="' + l.id + '">';
    html += '<div class="lesson-card-title">' + escHtml(l.title) + '</div>';
    html += '<div class="lesson-card-meta"><span>' + dateStr + '</span><span>' + unique.length + ' mots</span></div>';
    var pageLabel = (l.currentPage > 0) ? ' Â· p.' + (l.currentPage + 1) : '';
    html += '<div class="lesson-card-progress">';
    html += '<span>ğŸ”µ ' + newC + '</span>';
    html += '<span>ğŸŸ¡ ' + savedC + '</span>';
    html += '<span>âšª ' + knownC + '</span>';
    html += '<span style="margin-left:auto;font-weight:600;">' + pctKnown + '%' + pageLabel + '</span>';
    html += '</div>';
    html += '<div class="lesson-card-bar"><div class="lesson-card-bar-fill" style="width:' + pctKnown + '%;background:var(--green);"></div></div>';
    html += '<div class="lesson-card-actions">';
    html += '<button class="lesson-btn-resume" data-resume="' + l.id + '">â–¶ Reprendre</button>';
    html += '<button class="lesson-btn-delete" data-del="' + l.id + '">ğŸ—‘</button>';
    html += '</div>';
    html += '</div>';
  }

  container.innerHTML = html;

  // Event listeners
  container.querySelectorAll('[data-resume]').forEach(function(btn) {
    btn.addEventListener('click', async function(e) {
      e.stopPropagation();
      var id = parseInt(this.dataset.resume);
      var lesson = await dbGet('lessons', id);
      if (lesson) openLesson(lesson);
    });
  });

  container.querySelectorAll('[data-del]').forEach(function(btn) {
    btn.addEventListener('click', async function(e) {
      e.stopPropagation();
      var id = parseInt(this.dataset.del);
      if (confirm('Supprimer cette leÃ§on ?')) {
        await deleteLesson(id);
        renderLessonList();
        showToast('LeÃ§on supprimÃ©e');
      }
    });
  });
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

document.getElementById('btnCloseText').addEventListener('click', () => {
  document.getElementById('importArea').style.display = '';
  document.getElementById('readerContent').classList.remove('has-text');
  document.getElementById('textBody').innerHTML = '';
  currentLessonId = null;
  allChunks = [];
  pages = [];
  currentPage = 0;
  renderLessonList();
});

// â”€â”€ Build pages from text â”€â”€
// â”€â”€ Split text into fine-grained chunks (sentences) â”€â”€
function splitIntoChunks(text) {
  var paragraphs = text.split(/\n+/).filter(function(p) { return p.trim().length > 0; });
  var chunks = [];
  for (var i = 0; i < paragraphs.length; i++) {
    var para = paragraphs[i].trim();
    // Split long paragraphs into sentences (keep punctuation with sentence)
    var sentences = para.match(/[^.!?â€¦]+[.!?â€¦]+[\s]*/g);
    if (sentences && sentences.length > 1) {
      for (var s = 0; s < sentences.length; s++) {
        var sent = sentences[s].trim();
        if (sent.length > 0) chunks.push(sent);
      }
    } else {
      // Short paragraph or no sentence-ending punctuation â€” keep as-is
      chunks.push(para);
    }
  }
  return chunks;
}

// â”€â”€ Build pages dynamically using real overflow detection â”€â”€
function buildPages(text) {
  allChunks = splitIntoChunks(text);
  pages = [];

  if (allChunks.length === 0) {
    pages = [[0]];
    return;
  }

  var body = document.getElementById('textBody');
  body.style.fontSize = settings.fontSize + 'px';
  body.style.lineHeight = '1.75';

  var chunkIndex = 0;
  while (chunkIndex < allChunks.length) {
    var pageChunks = [];
    body.innerHTML = '';

    // Add chunks one by one until it overflows
    while (chunkIndex < allChunks.length) {
      // Render test paragraph
      var testP = document.createElement('p');
      testP.textContent = allChunks[chunkIndex];
      body.appendChild(testP);

      // Check overflow
      if (pageChunks.length > 0 && body.scrollHeight > body.clientHeight) {
        // This chunk caused overflow â€” remove it, belongs to next page
        body.removeChild(testP);
        break;
      }

      pageChunks.push(chunkIndex);
      chunkIndex++;
    }

    // Safety: if one single chunk is too big, still put it on a page
    if (pageChunks.length === 0 && chunkIndex < allChunks.length) {
      pageChunks.push(chunkIndex);
      chunkIndex++;
    }

    pages.push(pageChunks);
  }

  body.innerHTML = '';
  if (pages.length === 0) pages = [[0]];
}

// â”€â”€ Show a specific page (ebook style â€” no scroll) â”€â”€
function showPage(pageIndex) {
  currentPage = pageIndex;
  var body = document.getElementById('textBody');

  // Page turn animation
  body.classList.remove('page-visible');
  body.classList.add('page-turning');

  setTimeout(function() {
    body.innerHTML = '';
    body.style.fontSize = settings.fontSize + 'px';
    body.style.lineHeight = '1.75';

    var chunkIndices = pages[currentPage] || [];
    var newCount = 0, savedCount = 0, knownCount = 0;

    for (var i = 0; i < chunkIndices.length; i++) {
      var chunkText = allChunks[chunkIndices[i]] || '';
      if (!chunkText.trim()) continue;

      var p = document.createElement('p');

      var parts = chunkText.split(RU_WORD);
      for (var j = 0; j < parts.length; j++) {
        var part = parts[j];
        if (!part) continue;

        if (/^[Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]+$/.test(part)) {
          var lower = part.toLowerCase();
          var span = document.createElement('span');
          span.className = 'w';
          span.textContent = part;
          span.dataset.w = lower;

          var cached = wordCache.get(lower);
          if (cached) {
            if (cached.status === 'known') { span.classList.add('w-known'); knownCount++; }
            else if (cached.status === 'ignored') { span.classList.add('w-ignored'); }
            else { span.classList.add('w-saved'); savedCount++; }
          } else {
            span.classList.add('w-new');
            newCount++;
          }
          span.addEventListener('click', onWordTap);
          p.appendChild(span);
        } else {
          p.appendChild(document.createTextNode(part));
        }
      }
      body.appendChild(p);
    }

    document.getElementById('countNew').textContent = newCount;
    document.getElementById('countSaved').textContent = savedCount;
    document.getElementById('countKnown').textContent = knownCount;

    updatePageNav();
    body.classList.remove('page-turning');
    body.classList.add('page-visible');
  }, 80);

  savePagePosition();
}

// â”€â”€ Update page nav UI â”€â”€
function updatePageNav() {
  var total = pages.length;
  document.getElementById('pageInfo').textContent = (currentPage + 1) + ' / ' + total;
  document.getElementById('btnPrevPage').disabled = (currentPage <= 0);

  var nextBtn = document.getElementById('btnNextPage');
  if (currentPage >= total - 1) {
    nextBtn.textContent = 'âœ… Fin';
    nextBtn.disabled = false;  // Keep clickable to finish lesson
    nextBtn.classList.remove('next-btn');
    nextBtn.style.background = 'var(--green)';
    nextBtn.style.color = '#fff';
    nextBtn.style.borderColor = 'var(--green)';
  } else {
    nextBtn.textContent = 'Suiv â†’';
    nextBtn.disabled = false;
    nextBtn.classList.add('next-btn');
    nextBtn.style.background = '';
    nextBtn.style.color = '';
    nextBtn.style.borderColor = '';
  }

  var pct = total > 1 ? ((currentPage + 1) / total * 100) : 100;
  document.getElementById('pageProgressFill').style.width = pct + '%';
}

// â”€â”€ Re-color words on current page â”€â”€
function recolorWords() {
  let newC = 0, savedC = 0, knownC = 0;
  document.querySelectorAll('#textBody .w').forEach(span => {
    const lower = span.dataset.w;
    const cached = wordCache.get(lower);
    span.className = 'w';
    if (cached) {
      if (cached.status === 'known') { span.classList.add('w-known'); knownC++; }
      else if (cached.status === 'ignored') { span.classList.add('w-ignored'); }
      else { span.classList.add('w-saved'); savedC++; }
    } else {
      span.classList.add('w-new');
      newC++;
    }
  });
  document.getElementById('countNew').textContent = newC;
  document.getElementById('countSaved').textContent = savedC;
  document.getElementById('countKnown').textContent = knownC;
}

// â”€â”€ Auto-mark blue words as known on current page â”€â”€
async function autoMarkPageBlueWords() {
  var blueWords = document.querySelectorAll('#textBody .w.w-new');
  if (blueWords.length === 0) return 0;

  var seen = {};
  var toMark = [];
  for (var i = 0; i < blueWords.length; i++) {
    var w = blueWords[i].dataset.w;
    if (!seen[w]) { seen[w] = true; toMark.push(w); }
  }

  var now = new Date().toISOString();
  for (var j = 0; j < toMark.length; j++) {
    var word = toMark[j];
    var existing = wordCache.get(word);
    if (existing) {
      existing.status = 'known';
      existing.lastSeen = now;
      await dbPut('words', existing);
      wordCache.set(word, existing);
    } else {
      var entry = {
        word: word, wordLower: word, translation: '', status: 'known',
        encounters: 1, contexts: [], createdAt: now, lastSeen: now
      };
      var id = await dbAdd('words', entry);
      entry.id = id;
      wordCache.set(word, entry);
    }
  }
  return toMark.length;
}

// â”€â”€ Save page position to lesson â”€â”€
async function savePagePosition() {
  if (!currentLessonId) return;
  try {
    var les = await dbGet('lessons', currentLessonId);
    if (les) {
      les.currentPage = currentPage;
      les.lastOpenedAt = new Date().toISOString();
      await dbPut('lessons', les);
    }
  } catch (e) {}
}

// â”€â”€ Page navigation â”€â”€
document.getElementById('btnNextPage').addEventListener('click', async function() {
  var count = await autoMarkPageBlueWords();
  if (count > 0) showToast('âœ“ ' + count + ' mot' + (count > 1 ? 's' : '') + ' â†’ connus');

  if (currentPage >= pages.length - 1) {
    // Last page â€” finish lesson
    showToast('ğŸ‰ LeÃ§on terminÃ©e !');
    setTimeout(function() {
      document.getElementById('importArea').style.display = '';
      document.getElementById('readerContent').classList.remove('has-text');
      document.getElementById('textBody').innerHTML = '';
      currentLessonId = null;
      allChunks = [];
      pages = [];
      currentPage = 0;
      renderLessonList();
      renderVocabList();
    }, 800);
    return;
  }

  showPage(currentPage + 1);
});

document.getElementById('btnPrevPage').addEventListener('click', function() {
  if (currentPage <= 0) return;
  showPage(currentPage - 1);
});

// â”€â”€ Swipe gestures for page turning â”€â”€
function setupSwipe() {
  var body = document.getElementById('textBody');
  var startX = 0, startY = 0, swiping = false;

  body.addEventListener('touchstart', function(e) {
    if (e.touches.length !== 1) return;
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    swiping = true;
  }, { passive: true });

  body.addEventListener('touchend', async function(e) {
    if (!swiping) return;
    swiping = false;
    var endX = e.changedTouches[0].clientX;
    var endY = e.changedTouches[0].clientY;
    var dx = endX - startX;
    var dy = endY - startY;

    // Only count horizontal swipes (dx > 60px and more horizontal than vertical)
    if (Math.abs(dx) < 60 || Math.abs(dy) > Math.abs(dx)) return;

    if (dx < 0 && currentPage < pages.length - 1) {
      // Swipe left = next page
      var count = await autoMarkPageBlueWords();
      if (count > 0) showToast('âœ“ ' + count + ' mot' + (count > 1 ? 's' : '') + ' â†’ connus');
      showPage(currentPage + 1);
    } else if (dx > 0 && currentPage > 0) {
      // Swipe right = previous page
      showPage(currentPage - 1);
    }
  }, { passive: true });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORD TAP â†’ Panel
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function onWordTap(e) {
  e.preventDefault();
  e.stopPropagation();
  const span = e.currentTarget;
  const word = span.dataset.w;

  // Highlight
  document.querySelectorAll('.w.w-active').forEach(el => el.classList.remove('w-active'));
  span.classList.add('w-active');

  // Get context sentence
  let ctx = '';
  const par = span.closest('p');
  if (par) {
    ctx = par.textContent.trim();
    if (ctx.length > 300) ctx = ctx.substring(0, 300) + 'â€¦';
  }

  currentWord = word;
  currentCtx = ctx;

  showWordPanel(word, ctx);
  speakRussian(word);
}

function showWordPanel(word, ctx) {
  const panel = document.getElementById('wordPanel');
  const overlay = document.getElementById('panelOverlay');

  document.getElementById('panelWord').textContent = word;
  document.getElementById('panelTrans').innerHTML = '<span class="spinner"></span>';
  document.getElementById('panelAlts').innerHTML = '';
  document.getElementById('panelCtx').textContent = ctx ? `Â« ${ctx} Â»` : '';
  document.getElementById('panelSent').style.display = 'none';
  document.getElementById('panelSent').textContent = '';

  overlay.classList.add('show');
  panel.classList.add('show');

  // Check if word already in DB
  const cached = wordCache.get(word);
  if (cached) {
    document.getElementById('panelSave').textContent = 'ğŸ“ Update';
    if (cached.translation) {
      document.getElementById('panelTrans').textContent = cached.translation;
    }
  } else {
    document.getElementById('panelSave').textContent = 'ğŸ’¾ Save';
  }

  // Fetch translation (offline: use cached; online: try Google Translate)
  fetchTranslation(word, ctx);
}

function hideWordPanel() {
  document.getElementById('wordPanel').classList.remove('show');
  document.getElementById('panelOverlay').classList.remove('show');
  document.querySelectorAll('.w.w-active').forEach(el => el.classList.remove('w-active'));
  currentWord = null;
}

document.getElementById('panelOverlay').addEventListener('click', hideWordPanel);

// â”€â”€ Pronunciation â”€â”€
document.getElementById('panelSpeak').addEventListener('click', function(e) {
  e.stopPropagation();
  if (!currentWord) return;
  speakRussian(currentWord);
});

function speakRussian(word) {
  if (!word) return;
  if ('speechSynthesis' in window) {
    speechSynthesis.cancel();
    var u = new SpeechSynthesisUtterance(word);
    u.lang = 'ru-RU';
    u.rate = 0.85;
    if (cachedRuVoice) {
      u.voice = cachedRuVoice;
    } else {
      var voices = speechSynthesis.getVoices();
      var ruVoice = voices.find(function(v) { return v.lang && v.lang.startsWith('ru'); });
      if (ruVoice) { u.voice = ruVoice; cachedRuVoice = ruVoice; }
    }
    var spoke = false;
    u.onstart = function() { spoke = true; };
    u.onerror = function() { if (!spoke) playTTSFallback(word); };
    speechSynthesis.speak(u);
    setTimeout(function() {
      if (!spoke && !speechSynthesis.speaking) { speechSynthesis.cancel(); playTTSFallback(word); }
    }, 500);
    return;
  }
  playTTSFallback(word);
}

function playTTSFallback(word) {
  var audio = new Audio('https://translate.googleapis.com/translate_tts?ie=UTF-8&client=gtx&tl=ru&q=' + encodeURIComponent(word));
  audio.volume = 1.0;
  audio.play().catch(function() {});
}

// â”€â”€ Translation â”€â”€
async function fetchTranslation(word, sentence) {
  try {
    var translation = '';
    var altsHtml = '';

    // Strategy 1: Lingva Translate (Google Translate proxy â€” no rate limit)
    var lingvaInstances = [
      'https://lingva.ml',
      'https://lingva.thedaviddelta.com',
      'https://translate.plausibility.cloud'
    ];

    for (var li = 0; li < lingvaInstances.length; li++) {
      try {
        var lUrl = lingvaInstances[li] + '/api/v1/ru/fr/' + encodeURIComponent(word);
        var lr = await fetchWithTimeout(lUrl, {}, 4000);
        if (lr.ok) {
          var ld = await lr.json();
          if (ld.translation) {
            translation = ld.translation;
            break;
          }
        }
      } catch (e) { /* try next */ }
    }

    // Strategy 2: MyMemory (free, 5000 words/day)
    if (!translation) {
      try {
        var mmUrl = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(word) + '&langpair=ru|fr';
        var mr = await fetchWithTimeout(mmUrl, {}, 4000);
        if (mr.ok) {
          var md = await mr.json();
          if (md.responseData && md.responseData.translatedText) {
            translation = md.responseData.translatedText;
          }
          // Alternatives from matches
          if (md.matches && md.matches.length > 1) {
            var seen = {};
            for (var mi = 0; mi < Math.min(md.matches.length, 5); mi++) {
              var mt = md.matches[mi].translation;
              if (mt && !seen[mt] && mt !== translation) {
                seen[mt] = true;
                altsHtml += mt + ', ';
              }
            }
            if (altsHtml) altsHtml = altsHtml.slice(0, -2);
          }
        }
      } catch (e) { /* continue */ }
    }

    // Strategy 3: Google Translate direct (last resort)
    if (!translation) {
      try {
        var gp = 'client=gtx&sl=ru&tl=fr&dt=t&dt=bd&q=' + encodeURIComponent(word);
        var gr = await fetchWithTimeout('https://translate.googleapis.com/translate_a/single?' + gp, {}, 4000);
        var gd = await gr.json();
        if (gd && gd[0]) {
          for (var gi = 0; gi < gd[0].length; gi++) {
            if (gd[0][gi] && gd[0][gi][0]) translation += gd[0][gi][0];
          }
        }
        if (gd && gd[1]) {
          altsHtml = '';
          for (var ai = 0; ai < gd[1].length; ai++) {
            var entry = gd[1][ai];
            if (entry[0]) altsHtml += '<b>' + entry[0] + '</b> ';
            if (entry[1]) altsHtml += entry[1].slice(0, 4).join(', ');
            altsHtml += '<br>';
          }
        }
      } catch (e) { /* give up */ }
    }

    document.getElementById('panelTrans').textContent = translation || 'â€”';
    document.getElementById('panelTrans').dataset.value = translation || '';
    if (altsHtml) {
      document.getElementById('panelAlts').innerHTML = altsHtml;
    }

    // Sentence translation (MyMemory â€” more reliable than Google direct)
    if (sentence && sentence.length > word.length + 5) {
      try {
        var sq = sentence.substring(0, 300);
        var sentTrans = '';

        // Try Lingva first for sentence
        for (var si = 0; si < lingvaInstances.length; si++) {
          try {
            var slUrl = lingvaInstances[si] + '/api/v1/ru/fr/' + encodeURIComponent(sq);
            var slr = await fetchWithTimeout(slUrl, {}, 4000);
            if (slr.ok) {
              var sld = await slr.json();
              if (sld.translation) { sentTrans = sld.translation; break; }
            }
          } catch (e) { /* next */ }
        }

        // Fallback to MyMemory for sentence
        if (!sentTrans) {
          var smUrl = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(sq) + '&langpair=ru|fr';
          var smr = await fetchWithTimeout(smUrl, {}, 4000);
          if (smr.ok) {
            var smd = await smr.json();
            if (smd.responseData && smd.responseData.translatedText) {
              sentTrans = smd.responseData.translatedText;
            }
          }
        }

        if (sentTrans) {
          document.getElementById('panelSent').textContent = 'ğŸ“– ' + sentTrans;
          document.getElementById('panelSent').style.display = 'block';
        }
      } catch (e) { /* no sentence translation */ }
    }

  } catch (err) {
    // Offline â€” try cached
    var cached = wordCache.get(word);
    if (cached && cached.translation) {
      document.getElementById('panelTrans').textContent = cached.translation;
      document.getElementById('panelTrans').dataset.value = cached.translation;
    } else {
      document.getElementById('panelTrans').textContent = '(hors ligne)';
      document.getElementById('panelTrans').dataset.value = '';
    }
  }
}

// â”€â”€ Save / Known / Ignore â”€â”€
document.getElementById('panelSave').addEventListener('click', () => saveWord('saved'));
document.getElementById('panelKnown').addEventListener('click', () => saveWord('known'));
document.getElementById('panelIgnore').addEventListener('click', () => saveWord('ignored'));

async function saveWord(status) {
  if (!currentWord) return;
  const word = currentWord;
  const translation = document.getElementById('panelTrans').dataset.value || '';
  const now = new Date().toISOString();

  const existing = wordCache.get(word);

  if (existing) {
    // Update
    existing.status = status;
    existing.encounters = (existing.encounters || 1) + 1;
    existing.lastSeen = now;
    if (translation && !existing.translation) existing.translation = translation;
    if (currentCtx && !existing.contexts?.includes(currentCtx)) {
      existing.contexts = existing.contexts || [];
      if (existing.contexts.length < 10) existing.contexts.push(currentCtx);
    }
    await dbPut('words', existing);
    wordCache.set(word, existing);
  } else {
    // New
    const entry = {
      word: word,
      wordLower: word,
      translation: translation,
      status: status,
      encounters: 1,
      contexts: currentCtx ? [currentCtx] : [],
      createdAt: now,
      lastSeen: now
    };
    const id = await dbAdd('words', entry);
    entry.id = id;
    wordCache.set(word, entry);
  }

  const label = status === 'known' ? 'âœ“ Known' : status === 'ignored' ? 'âœ— Ignored' : 'âœ“ Saved';
  showToast(`${label}: ${word}`);
  hideWordPanel();
  recolorWords();
}

// (Auto-mark on page turn replaces the old "finish lesson" button)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VOCAB LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let vocabFilter = 'all';
let vocabQuery = '';

document.querySelectorAll('#filterChips .chip').forEach(chip => {
  chip.addEventListener('click', () => {
    document.querySelectorAll('#filterChips .chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    vocabFilter = chip.dataset.filter;
    renderVocabList();
  });
});

document.getElementById('vocabSearch').addEventListener('input', (e) => {
  vocabQuery = e.target.value.toLowerCase().trim();
  renderVocabList();
});

async function renderVocabList() {
  const list = document.getElementById('wordList');
  let words = await dbGetAll('words');

  // Filter
  if (vocabFilter !== 'all') {
    words = words.filter(w => w.status === vocabFilter);
  }
  if (vocabQuery) {
    words = words.filter(w =>
      w.word.includes(vocabQuery) ||
      (w.translation && w.translation.toLowerCase().includes(vocabQuery))
    );
  }

  // Sort by newest first
  words.sort((a, b) => (b.createdAt || '').localeCompare(a.createdAt || ''));

  if (words.length === 0) {
    list.innerHTML = '<div class="empty-state"><div class="big">ğŸ“š</div>No words yet.<br>Start reading to build your vocabulary!</div>';
    return;
  }

  list.innerHTML = words.map(w => `
    <div class="word-card" data-id="${w.id}">
      <div class="wc-status st-${w.status || 'new'}"></div>
      <div class="wc-word">${escHtml(w.word)}</div>
      <div class="wc-trans">${escHtml(w.translation || '')}</div>
    </div>
  `).join('');

  list.querySelectorAll('.word-card').forEach(card => {
    card.addEventListener('click', () => showWordDetail(+card.dataset.id));
  });
}

async function showWordDetail(id) {
  const w = await dbGet('words', id);
  if (!w) return;

  document.getElementById('detailWord').textContent = w.word;
  document.getElementById('detailTrans').textContent = w.translation || 'â€”';

  const statusLabel = { new: 'New', saved: 'Saved', learning: 'Learning', known: 'Known', ignored: 'Ignored' };
  document.getElementById('detailMeta').innerHTML = `
    <span class="detail-badge b-status">${statusLabel[w.status] || w.status}</span>
    <span class="detail-badge b-encounters">${w.encounters || 1} encounter${(w.encounters||1) > 1 ? 's' : ''}</span>
  `;

  const ctxHtml = (w.contexts || []).map(c => `<div class="detail-ctx-item">Â« ${escHtml(c)} Â»</div>`).join('');
  document.getElementById('detailContexts').innerHTML = ctxHtml || '<div style="color:var(--muted);font-size:13px;">No context saved</div>';

  document.getElementById('detailKnown').onclick = async () => {
    w.status = 'known';
    await dbPut('words', w);
    wordCache.set(w.wordLower, w);
    recolorWords();
    closeModal('detailModal');
    renderVocabList();
    showToast('âœ“ Marked as known');
  };

  document.getElementById('detailDelete').onclick = async () => {
    if (confirm('Delete "' + w.word + '" from vocabulary?')) {
      await dbDelete('words', w.id);
      wordCache.delete(w.wordLower);
      recolorWords();
      closeModal('detailModal');
      renderVocabList();
      showToast('ğŸ—‘ Deleted');
    }
  };

  openModal('detailModal');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function renderStats() {
  const words = await dbGetAll('words');
  const total = words.length;
  const newW = words.filter(w => w.status === 'new').length;
  const learning = words.filter(w => w.status === 'saved' || w.status === 'learning').length;
  const known = words.filter(w => w.status === 'known').length;

  document.getElementById('statTotal').textContent = total;
  document.getElementById('statNew').textContent = newW;
  document.getElementById('statLearning').textContent = learning;
  document.getElementById('statKnown').textContent = known;

  // Progress bar
  if (total > 0) {
    document.getElementById('prgNew').style.width = (newW / total * 100) + '%';
    document.getElementById('prgLearning').style.width = (learning / total * 100) + '%';
    document.getElementById('prgKnown').style.width = (known / total * 100) + '%';
  }

  // Activity: group by date
  const byDate = {};
  for (const w of words) {
    const d = (w.createdAt || '').substring(0, 10);
    if (d) byDate[d] = (byDate[d] || 0) + 1;
  }
  const dates = Object.entries(byDate).sort((a, b) => b[0].localeCompare(a[0])).slice(0, 14);
  const actEl = document.getElementById('activityList');

  if (dates.length === 0) {
    actEl.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px;">No activity yet</div>';
    return;
  }

  actEl.innerHTML = dates.map(([date, count]) => `
    <div style="display:flex;align-items:center;gap:10px;padding:8px 12px;background:var(--surface);border-radius:10px;">
      <span style="font-family:'JetBrains Mono';font-size:12px;color:var(--muted);min-width:80px;">${date}</span>
      <div style="flex:1;height:6px;background:var(--surface2);border-radius:3px;overflow:hidden;">
        <div style="width:${Math.min(count * 5, 100)}%;height:100%;background:var(--accent);border-radius:3px;"></div>
      </div>
      <span style="font-family:'JetBrains Mono';font-size:13px;font-weight:600;color:var(--accent);min-width:24px;text-align:right;">+${count}</span>
    </div>
  `).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT / IMPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('btnExport').addEventListener('click', async () => {
  const words = await dbGetAll('words');
  const data = { version: 1, exportedAt: new Date().toISOString(), words };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `rusvault-export-${new Date().toISOString().substring(0, 10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showToast('ğŸ“¤ Exported!');
});

document.getElementById('btnImport').addEventListener('click', () => {
  document.getElementById('importDbInput').click();
});

document.getElementById('importDbInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    const text = await file.text();
    const data = JSON.parse(text);
    const words = data.words || data;

    if (!Array.isArray(words)) {
      showToast('âŒ Invalid file format');
      return;
    }

    let imported = 0;
    for (const w of words) {
      const lower = (w.wordLower || w.word || '').toLowerCase();
      if (!lower) continue;

      const existing = wordCache.get(lower);
      if (existing) {
        // Merge: keep higher encounter count, merge contexts
        existing.encounters = Math.max(existing.encounters || 1, w.encounters || 1);
        if (w.translation && !existing.translation) existing.translation = w.translation;
        if (w.contexts) {
          existing.contexts = existing.contexts || [];
          for (const c of w.contexts) {
            if (!existing.contexts.includes(c) && existing.contexts.length < 10) {
              existing.contexts.push(c);
            }
          }
        }
        await dbPut('words', existing);
      } else {
        const entry = {
          word: w.word || lower,
          wordLower: lower,
          translation: w.translation || '',
          status: w.status || 'new',
          encounters: w.encounters || 1,
          contexts: w.contexts || [],
          createdAt: w.createdAt || new Date().toISOString(),
          lastSeen: w.lastSeen || new Date().toISOString()
        };
        await dbAdd('words', entry);
        imported++;
      }
    }

    await loadWordCache();
    showToast(`ğŸ“¥ Imported ${imported} new words!`);
    recolorWords();
  } catch (err) {
    showToast('âŒ Import error: ' + err.message);
  }
  e.target.value = '';
});

document.getElementById('btnClear').addEventListener('click', async () => {
  if (!confirm('Delete ALL vocabulary data? This cannot be undone.')) return;
  if (!confirm('Are you really sure?')) return;
  await dbClear('words');
  await dbClear('sources');
  wordCache.clear();
  recolorWords();
  showToast('ğŸ—‘ All data cleared');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODALS & TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openModal(id) {
  const el = document.getElementById(id);
  el.classList.add('show');
  el.addEventListener('click', (e) => {
    if (e.target === el) closeModal(id);
  }, { once: true });
}

// make closeModal global for inline onclick
window.closeModal = function(id) {
  document.getElementById(id).classList.remove('show');
};

let toastTimer;
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.classList.remove('show'), 2200);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VERCEL BACKEND URL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function() {
  var input = document.getElementById('vercelUrlInput');
  if (!input) return;
  var saved = localStorage.getItem('rusvault_vercel_url') || '';
  if (saved) input.value = saved;

  document.getElementById('btnSaveVercel').addEventListener('click', function() {
    var url = input.value.trim();
    if (url && !url.startsWith('https://')) {
      showToast('âŒ L\'URL doit commencer par https://');
      return;
    }
    if (url) {
      localStorage.setItem('rusvault_vercel_url', url);
      showToast('âœ“ URL Vercel sauvegardÃ©e !');
    } else {
      localStorage.removeItem('rusvault_vercel_url');
      showToast('URL Vercel supprimÃ©e');
    }
  });
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FLASHCARD MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Toggle list vs flashcard
document.getElementById('btnVocabList').addEventListener('click', function() {
  this.classList.add('active');
  document.getElementById('btnVocabFlash').classList.remove('active');
  document.getElementById('vocabListMode').style.display = '';
  document.getElementById('vocabFlashMode').style.display = 'none';
});

document.getElementById('btnVocabFlash').addEventListener('click', function() {
  this.classList.add('active');
  document.getElementById('btnVocabList').classList.remove('active');
  document.getElementById('vocabListMode').style.display = 'none';
  document.getElementById('vocabFlashMode').style.display = '';
  populateFlashcardSetup();
});

// --- Chip selection helpers ---
function setupChipGroup(containerId, callback) {
  var container = document.getElementById(containerId);
  if (!container) return;
  container.addEventListener('click', function(e) {
    var chip = e.target.closest('.fc-chip');
    if (!chip) return;
    container.querySelectorAll('.fc-chip').forEach(function(c) { c.classList.remove('active'); });
    chip.classList.add('active');
    if (callback) callback();
  });
}

setupChipGroup('fcLessonChips', updateFcWordCount);
setupChipGroup('fcCountChips', updateFcWordCount);

async function populateFlashcardSetup() {
  var container = document.getElementById('fcLessonChips');
  // Keep "all" and "due" chips, add lesson-specific chips
  var lessons = await dbGetAll('lessons');
  // Remove old lesson chips
  container.querySelectorAll('[data-lesson-id]').forEach(function(c) { c.remove(); });

  for (var i = 0; i < lessons.length; i++) {
    var btn = document.createElement('button');
    btn.className = 'fc-chip';
    btn.dataset.lessonId = lessons[i].id;
    btn.dataset.lesson = 'lesson-' + lessons[i].id;
    btn.textContent = lessons[i].title.length > 18 ? lessons[i].title.substring(0, 18) + 'â€¦' : lessons[i].title;
    container.appendChild(btn);
  }
  updateFcWordCount();
}

async function getFcCandidateWords() {
  var activeChip = document.querySelector('#fcLessonChips .fc-chip.active');
  var lessonFilter = activeChip ? activeChip.dataset.lesson : 'all';

  var allWords = await dbGetAll('words');
  var candidates = [];

  if (lessonFilter === 'all') {
    // All words that have a translation (saved, learning, known â€” not ignored)
    candidates = allWords.filter(function(w) {
      return w.status !== 'ignored' && w.translation;
    });
  } else if (lessonFilter === 'saved') {
    candidates = allWords.filter(function(w) {
      return w.status === 'saved' || w.status === 'learning';
    });
  } else if (lessonFilter === 'known') {
    candidates = allWords.filter(function(w) {
      return w.status === 'known' && w.translation;
    });
  } else if (lessonFilter === 'due') {
    var now = Date.now();
    candidates = allWords.filter(function(w) {
      if (w.status === 'ignored') return false;
      if (!w.translation) return false;
      if (!w.nextReview) return (w.status === 'saved' || w.status === 'learning');
      return new Date(w.nextReview).getTime() <= now;
    });
  } else {
    // Specific lesson
    var lessonId = parseInt(activeChip.dataset.lessonId);
    var lesson = await dbGet('lessons', lessonId);
    if (lesson) {
      var lessonWords = {};
      var matches = lesson.text.match(/[Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]+/g) || [];
      for (var m = 0; m < matches.length; m++) {
        lessonWords[matches[m].toLowerCase()] = true;
      }
      candidates = allWords.filter(function(w) {
        return lessonWords[w.wordLower || w.word] && w.status !== 'ignored' && w.translation;
      });
    }
  }

  return candidates;
}

function updateFcWordCount() {
  getFcCandidateWords().then(function(candidates) {
    var countChip = document.querySelector('#fcCountChips .fc-chip.active');
    var maxCount = countChip ? countChip.dataset.count : '20';
    var total = candidates.length;
    var actual = maxCount === 'all' ? total : Math.min(parseInt(maxCount), total);

    var msg = '';
    if (total === 0) {
      msg = 'âš ï¸ Aucun mot disponible. Sauvegarde des mots en lisant pour les rÃ©viser ici !';
    } else {
      msg = actual + ' carte' + (actual > 1 ? 's' : '') + ' disponible' + (actual > 1 ? 's' : '') + ' sur ' + total;
    }
    document.getElementById('fcWordCount').textContent = msg;
    document.getElementById('fcStartBtn').disabled = (actual === 0);
  });
}

// --- SRS Algorithm (SM-2 inspired, hidden from user) ---
function srsSchedule(word, grade) {
  // grade: 0=again, 1=hard, 2=good, 3=easy
  var interval = word.srsInterval || 0;  // in minutes
  var ease = word.srsEase || 2.5;
  var reps = word.srsReps || 0;
  var now = new Date();

  if (grade === 0) {
    // Again â€” reset, show again in 1 minute
    interval = 1;
    reps = 0;
    ease = Math.max(1.3, ease - 0.2);
  } else if (grade === 1) {
    // Hard
    if (reps === 0) { interval = 10; }
    else if (reps === 1) { interval = 60 * 24; }     // 1 day
    else { interval = interval * 1.2; }
    ease = Math.max(1.3, ease - 0.15);
    reps++;
  } else if (grade === 2) {
    // Good
    if (reps === 0) { interval = 60 * 24; }          // 1 day
    else if (reps === 1) { interval = 60 * 24 * 3; }  // 3 days
    else { interval = interval * ease; }
    reps++;
  } else if (grade === 3) {
    // Easy
    if (reps === 0) { interval = 60 * 24 * 3; }      // 3 days
    else if (reps === 1) { interval = 60 * 24 * 7; }  // 7 days
    else { interval = interval * ease * 1.3; }
    ease += 0.15;
    reps++;
  }

  var nextReview = new Date(now.getTime() + interval * 60 * 1000);

  // Determine if word is now "known"
  var newStatus = word.status;
  if (interval >= 60 * 24 * 21) {
    // 21+ days interval = considered known
    newStatus = 'known';
  } else {
    newStatus = 'learning';
  }

  return {
    srsInterval: Math.round(interval),
    srsEase: Math.round(ease * 100) / 100,
    srsReps: reps,
    nextReview: nextReview.toISOString(),
    status: newStatus
  };
}

function formatInterval(minutes) {
  if (minutes < 60) return Math.round(minutes) + 'm';
  if (minutes < 60 * 24) return Math.round(minutes / 60) + 'h';
  return Math.round(minutes / (60 * 24)) + 'j';
}

// --- Flashcard Session ---
var fcDeck = [];
var fcIndex = 0;
var fcRevealed = false;
var fcResults = { again: 0, hard: 0, good: 0, easy: 0 };

document.getElementById('fcStartBtn').addEventListener('click', async function() {
  var candidates = await getFcCandidateWords();
  if (candidates.length === 0) { showToast('Aucun mot Ã  rÃ©viser'); return; }

  var countChip = document.querySelector('#fcCountChips .fc-chip.active');
  var maxCount = countChip ? countChip.dataset.count : '20';
  var max = maxCount === 'all' ? candidates.length : parseInt(maxCount);

  // Shuffle
  for (var s = candidates.length - 1; s > 0; s--) {
    var r = Math.floor(Math.random() * (s + 1));
    var tmp = candidates[s]; candidates[s] = candidates[r]; candidates[r] = tmp;
  }

  // Prioritize: due items first, then by least seen
  candidates.sort(function(a, b) {
    var aDue = (!a.nextReview || new Date(a.nextReview).getTime() <= Date.now()) ? 0 : 1;
    var bDue = (!b.nextReview || new Date(b.nextReview).getTime() <= Date.now()) ? 0 : 1;
    if (aDue !== bDue) return aDue - bDue;
    return (a.srsReps || 0) - (b.srsReps || 0);
  });

  fcDeck = candidates.slice(0, max);
  fcIndex = 0;
  fcRevealed = false;
  fcResults = { again: 0, hard: 0, good: 0, easy: 0 };

  document.getElementById('fcSession').classList.add('active');
  showFcCard();
});

function showFcCard() {
  if (fcIndex >= fcDeck.length) {
    showFcResults();
    return;
  }

  var word = fcDeck[fcIndex];
  fcRevealed = false;

  document.getElementById('fcWord').textContent = word.word || word.wordLower;
  document.getElementById('fcHint').style.display = '';
  document.getElementById('fcAnswer').style.display = 'none';
  document.getElementById('fcCtx').style.display = 'none';
  document.getElementById('fcButtons').style.display = 'none';

  // Update progress
  document.getElementById('fcProgressText').textContent = (fcIndex + 1) + ' / ' + fcDeck.length;
  var pct = ((fcIndex) / fcDeck.length) * 100;
  document.getElementById('fcProgressFill').style.width = pct + '%';

  // Preview intervals for buttons
  var simulHard = srsSchedule(word, 1);
  var simulGood = srsSchedule(word, 2);
  var simulEasy = srsSchedule(word, 3);
  document.getElementById('fcHardInt').textContent = formatInterval(simulHard.srsInterval);
  document.getElementById('fcGoodInt').textContent = formatInterval(simulGood.srsInterval);
  document.getElementById('fcEasyInt').textContent = formatInterval(simulEasy.srsInterval);

  // Auto-speak
  speakRussian(word.word || word.wordLower);
}

// Reveal on card tap
document.getElementById('fcCard').addEventListener('click', function() {
  if (fcRevealed || fcIndex >= fcDeck.length) return;
  fcRevealed = true;

  var word = fcDeck[fcIndex];
  document.getElementById('fcHint').style.display = 'none';
  document.getElementById('fcAnswer').style.display = '';
  document.getElementById('fcAnswer').textContent = word.translation || '(pas de traduction)';

  if (word.contexts && word.contexts.length > 0) {
    document.getElementById('fcCtx').style.display = '';
    document.getElementById('fcCtx').textContent = 'Â« ' + word.contexts[0].substring(0, 120) + ' Â»';
  }

  document.getElementById('fcButtons').style.display = '';
});

// Speak button
document.getElementById('fcSpeak').addEventListener('click', function(e) {
  e.stopPropagation();
  if (fcIndex < fcDeck.length) {
    var word = fcDeck[fcIndex];
    speakRussian(word.word || word.wordLower);
  }
});

// Grade buttons
document.getElementById('fcButtons').addEventListener('click', async function(e) {
  var btn = e.target.closest('.fc-btn');
  if (!btn) return;
  var grade = parseInt(btn.dataset.grade);

  var word = fcDeck[fcIndex];
  var srs = srsSchedule(word, grade);

  // Update word in DB
  word.srsInterval = srs.srsInterval;
  word.srsEase = srs.srsEase;
  word.srsReps = srs.srsReps;
  word.nextReview = srs.nextReview;
  word.status = srs.status;
  word.lastSeen = new Date().toISOString();

  await dbPut('words', word);
  wordCache.set(word.wordLower || word.word, word);

  // Track results
  if (grade === 0) fcResults.again++;
  else if (grade === 1) fcResults.hard++;
  else if (grade === 2) fcResults.good++;
  else fcResults.easy++;

  // If "again", put card back in deck a few positions later
  if (grade === 0) {
    var reinsertAt = Math.min(fcIndex + 3 + Math.floor(Math.random() * 3), fcDeck.length);
    fcDeck.splice(reinsertAt, 0, word);
  }

  fcIndex++;
  showFcCard();
});

function showFcResults() {
  var total = fcResults.again + fcResults.hard + fcResults.good + fcResults.easy;
  var successRate = total > 0 ? Math.round(((fcResults.good + fcResults.easy) / total) * 100) : 0;

  var emoji = successRate >= 80 ? 'ğŸ†' : successRate >= 50 ? 'ğŸ’ª' : 'ğŸ“–';

  document.getElementById('fcCardArea').innerHTML =
    '<div class="fc-result">' +
      '<div class="fc-result-big">' + emoji + '</div>' +
      '<div class="fc-result-text">' + successRate + '% de rÃ©ussite</div>' +
      '<div class="fc-result-sub">' +
        'âŒ ' + fcResults.again + '  Â·  ğŸŸ¡ ' + fcResults.hard + '  Â·  âœ… ' + fcResults.good + '  Â·  â­ ' + fcResults.easy +
      '</div>' +
    '</div>';

  document.getElementById('fcButtons').style.display = 'none';
  document.getElementById('fcProgressFill').style.width = '100%';
  document.getElementById('fcProgressText').textContent = 'TerminÃ© !';
}

// Close flashcard session
document.getElementById('fcCloseBtn').addEventListener('click', function() {
  document.getElementById('fcSession').classList.remove('active');
  // Reset card area HTML for next session
  document.getElementById('fcCardArea').innerHTML =
    '<div class="fc-card" id="fcCard">' +
      '<div class="fc-card-word" id="fcWord">â€”</div>' +
      '<button class="fc-speak-btn" id="fcSpeak">ğŸ”Š</button>' +
      '<div class="fc-card-hint" id="fcHint">Tap pour rÃ©vÃ©ler</div>' +
      '<div class="fc-card-answer" id="fcAnswer" style="display:none;">â€”</div>' +
      '<div class="fc-card-ctx" id="fcCtx" style="display:none;"></div>' +
    '</div>';

  // Re-bind card and speak events
  document.getElementById('fcCard').addEventListener('click', function() {
    if (fcRevealed || fcIndex >= fcDeck.length) return;
    fcRevealed = true;
    var word = fcDeck[fcIndex];
    document.getElementById('fcHint').style.display = 'none';
    document.getElementById('fcAnswer').style.display = '';
    document.getElementById('fcAnswer').textContent = word.translation || '(pas de traduction)';
    if (word.contexts && word.contexts.length > 0) {
      document.getElementById('fcCtx').style.display = '';
      document.getElementById('fcCtx').textContent = 'Â« ' + word.contexts[0].substring(0, 120) + ' Â»';
    }
    document.getElementById('fcButtons').style.display = '';
  });
  document.getElementById('fcSpeak').addEventListener('click', function(e) {
    e.stopPropagation();
    if (fcIndex < fcDeck.length) speakRussian(fcDeck[fcIndex].word || fcDeck[fcIndex].wordLower);
  });

  renderVocabList();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function init() {
  loadSettings();
  await openDB();
  await loadWordCache();
  renderLessonList();
  console.log(`[RusVault] Ready. ${wordCache.size} words cached.`);
}

init().catch(function(err) { console.error('[RusVault] Init error:', err); });

// Service Worker â€” force update
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(function(regs) {
    regs.forEach(function(reg) { reg.update(); });
  });
  navigator.serviceWorker.register('sw.js').catch(function() {});
}

// Reset SW button
document.getElementById('btnResetSW').addEventListener('click', async function() {
  if (!('serviceWorker' in navigator)) { showToast('Pas de Service Worker'); return; }
  try {
    var regs = await navigator.serviceWorker.getRegistrations();
    for (var i = 0; i < regs.length; i++) {
      await regs[i].unregister();
    }
    var keys = await caches.keys();
    for (var j = 0; j < keys.length; j++) {
      await caches.delete(keys[j]);
    }
    showToast('âœ“ Reset OK ! Rechargementâ€¦');
    setTimeout(function() { window.location.reload(); }, 1000);
  } catch (e) {
    showToast('Erreur: ' + e.message);
  }
});

})();
</script>
</body>
</html>
