<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="LangVault">
<meta name="theme-color" content="#0a0a14">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>LangVault</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CSS VARIABLES & RESET
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg: #0a0a14;
  --surface: #12121f;
  --surface2: #1a1a2e;
  --surface3: #222240;
  --accent: #e94560;
  --accent-dim: rgba(233,69,96,0.15);
  --green: #4ecca3;
  --green-dim: rgba(78,204,163,0.15);
  --blue: #5b8def;
  --blue-dim: rgba(91,141,239,0.18);
  --yellow: #f0c040;
  --yellow-dim: rgba(240,192,64,0.18);
  --text: #e8e8f0;
  --muted: #6a6a80;
  --border: #2a2a3e;
  --radius: 14px;
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --tab-h: 64px;
}
[data-theme="light"] {
  --bg: #f5f5fa;
  --surface: #ffffff;
  --surface2: #eeeef4;
  --surface3: #e0e0ea;
  --text: #1a1a2e;
  --muted: #888;
  --border: #d8d8e4;
  --accent-dim: rgba(233,69,96,0.1);
  --green-dim: rgba(78,204,163,0.12);
  --blue-dim: rgba(91,141,239,0.12);
  --yellow-dim: rgba(200,160,40,0.15);
}

*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }
html { height:100%; -webkit-text-size-adjust:100%; }
body {
  font-family: 'Outfit', -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  height: 100%;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -webkit-tap-highlight-color: transparent;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   APP SHELL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.app {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
}
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 20px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  z-index: 50;
}
.logo {
  font-size: 20px;
  font-weight: 800;
  color: var(--accent);
  letter-spacing: -0.5px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.logo b { color: var(--green); }
.logo:active { opacity: 0.7; }
.header-actions { display: flex; gap: 8px; }

/* â”€â”€ Home / Language Select â”€â”€â”€ */
.home-view {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  text-align: center;
  min-height: 100%;
}
.home-hero { font-size: 40px; margin-bottom: 8px; }
.home-title {
  font-size: 28px;
  font-weight: 800;
  margin-bottom: 4px;
  color: var(--text);
}
.home-title b { color: var(--accent); }
.home-title span { color: var(--green); }
.home-sub {
  font-size: 14px;
  color: var(--muted);
  margin-bottom: 32px;
  max-width: 280px;
  line-height: 1.5;
}
.lang-cards {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
  max-width: 320px;
}
.lang-card {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 18px 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 16px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: left;
  font-family: inherit;
  color: var(--text);
  width: 100%;
  -webkit-tap-highlight-color: transparent;
}
.lang-card:active { transform: scale(0.97); }
.lang-card:hover { border-color: var(--accent); background: var(--accent-dim); }
.lang-card-flag { font-size: 32px; flex-shrink: 0; }
.lang-card-info { flex: 1; }
.lang-card-name { font-size: 16px; font-weight: 700; }
.lang-card-desc { font-size: 12px; color: var(--muted); margin-top: 2px; }
.lang-card-arrow { color: var(--muted); font-size: 18px; }
.icon-btn {
  width: 36px; height: 36px;
  border: none; border-radius: 10px;
  background: var(--surface2);
  color: var(--muted);
  font-size: 18px;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.15s;
}
.icon-btn:active { transform: scale(0.92); }
.icon-btn.active { color: var(--accent); background: var(--accent-dim); }

/* â”€â”€ View Container â”€â”€â”€ */
.views {
  flex: 1;
  overflow: hidden;
  position: relative;
}
.view {
  position: absolute;
  inset: 0;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  padding: 16px;
  padding-bottom: calc(var(--tab-h) + var(--safe-bottom) + 20px);
  display: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.view.active { display: block; opacity: 1; }

/* â”€â”€ Tab Bar â”€â”€â”€ */
.tab-bar {
  display: flex;
  background: var(--surface);
  border-top: 1px solid var(--border);
  padding-bottom: var(--safe-bottom);
  flex-shrink: 0;
  z-index: 50;
  transition: transform 0.25s, opacity 0.25s;
}
.tab-bar.hidden {
  transform: translateY(100%);
  opacity: 0;
  pointer-events: none;
  position: absolute;
  bottom: 0; left: 0; right: 0;
}
.tab {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3px;
  padding: 10px 4px 8px;
  background: none;
  border: none;
  color: var(--muted);
  font-size: 10px;
  font-family: inherit;
  font-weight: 500;
  cursor: pointer;
  transition: color 0.15s;
}
.tab svg { width: 22px; height: 22px; }
.tab.active { color: var(--accent); }
.tab:active { transform: scale(0.95); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   READER VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.import-area {
  background: var(--surface);
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  padding: 28px 20px;
  text-align: center;
  margin-bottom: 16px;
}
.import-area h2 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--muted);
}
.import-btns {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
}
.import-btn {
  padding: 10px 16px;
  border: 1px solid var(--border);
  border-radius: 10px;
  background: var(--surface2);
  color: var(--text);
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.15s;
}
.import-btn:active { transform: scale(0.96); background: var(--surface3); }
.import-btn .em { font-size: 16px; }

/* â”€â”€ Text Display Area (ebook mode) â”€â”€â”€ */
.reader-content {
  font-size: 18px;
  line-height: 1.75;
  display: none;
}
.reader-content.has-text {
  display: flex;
  flex-direction: column;
  position: absolute;
  inset: 0;
  padding: 0;
  overflow: hidden;
}
.reader-top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  flex-shrink: 0;
  border-bottom: 1px solid var(--border);
  background: var(--surface);
}
.reader-top-bar .reader-label {
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  margin-right: 8px;
}
.reader-top-bar .close-text {
  color: var(--muted);
  background: none;
  border: none;
  font-size: 22px;
  cursor: pointer;
  padding: 0 4px;
  flex-shrink: 0;
}
.reader-stats-bar {
  display: flex;
  gap: 12px;
  padding: 8px 16px;
  font-size: 11px;
  color: var(--muted);
  flex-shrink: 0;
  background: var(--surface);
}
.reader-stats-bar span b { font-weight: 600; }
.stat-new b { color: var(--blue); }
.stat-saved b { color: var(--yellow); }
.stat-known b { color: var(--green); }
.page-progress-bar {
  height: 3px;
  background: var(--surface2);
  flex-shrink: 0;
}
.page-progress-fill {
  height: 100%;
  background: var(--accent);
  transition: width 0.3s;
}

/* â”€â”€ Text body: FIXED height, no scroll â”€â”€â”€ */
#textBody {
  flex: 1;
  overflow: hidden;
  padding: 16px 18px;
  position: relative;
}
#textBody p {
  margin-bottom: 12px;
}

/* â”€â”€ Page navigation bar â”€â”€â”€ */
.page-nav {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  padding-bottom: calc(10px + var(--safe-bottom));
  flex-shrink: 0;
  border-top: 1px solid var(--border);
  background: var(--surface);
  gap: 10px;
}
.page-btn {
  padding: 12px 22px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--surface2);
  color: var(--text);
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 90px;
  text-align: center;
  -webkit-tap-highlight-color: transparent;
}
.page-btn:active { transform: scale(0.96); }
.page-btn:disabled { opacity: 0.25; pointer-events: none; }
.page-btn.next-btn { background: var(--accent); color: #fff; border-color: var(--accent); }
.page-btn.next-btn:active { opacity: 0.85; }
.page-btn.next-btn:disabled { opacity: 0.25; }
.page-info {
  font-family: 'JetBrains Mono', monospace;
  font-size: 13px;
  color: var(--muted);
  text-align: center;
  white-space: nowrap;
}

/* â”€â”€ Page transition animation â”€â”€â”€ */
#textBody.page-turning {
  opacity: 0.3;
  transition: opacity 0.1s;
}
#textBody.page-visible {
  opacity: 1;
  transition: opacity 0.15s;
}

/* â”€â”€ Word tokens â”€â”€â”€ */
.w {
  cursor: pointer;
  border-radius: 3px;
  transition: background 0.12s;
  padding: 1px 1px;
}
.w:active { transform: scale(0.97); }
.w.w-new { color: var(--blue); background: var(--blue-dim); }
.w.w-saved { color: var(--yellow); background: var(--yellow-dim); }
.w.w-known { color: var(--text); opacity: 0.5; }
.w.w-ignored { color: var(--text); opacity: 0.35; }
.w.w-active {
  background: var(--accent-dim) !important;
  color: var(--accent) !important;
  opacity: 1 !important;
  outline: 2px solid var(--accent);
  outline-offset: 1px;
  border-radius: 4px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WORD PANEL (bottom sheet)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.word-panel-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 100;
  display: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.word-panel-overlay.show { display: block; opacity: 1; }
.word-panel {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  background: var(--surface);
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  z-index: 101;
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  max-height: 55vh;
  overflow-y: auto;
  padding-bottom: calc(var(--safe-bottom) + 12px);
}
.word-panel.show { transform: translateY(0); }
.panel-handle {
  width: 36px; height: 4px;
  background: var(--border);
  border-radius: 2px;
  margin: 10px auto 0;
}
.panel-body { padding: 16px 20px; }
.panel-word {
  font-size: 26px;
  font-weight: 800;
  color: var(--accent);
  margin-bottom: 2px;
}
.panel-translation {
  font-size: 20px;
  font-weight: 600;
  color: var(--green);
  min-height: 28px;
  margin-bottom: 4px;
}
.panel-alts {
  font-size: 13px;
  color: var(--muted);
  line-height: 1.6;
  margin-bottom: 8px;
}
.panel-alts b { color: var(--accent); font-weight: 600; }
.panel-ctx {
  font-size: 12px;
  color: var(--muted);
  font-style: italic;
  padding: 8px 10px;
  background: var(--surface2);
  border-radius: 8px;
  margin-bottom: 12px;
  max-height: 60px;
  overflow: hidden;
}
.panel-sent {
  font-size: 13px;
  color: var(--blue);
  padding: 8px 10px;
  background: rgba(91,141,239,0.08);
  border-radius: 8px;
  margin-bottom: 12px;
  display: none;
}
#panelDict a {
  color: var(--accent); font-size: 12px; text-decoration: none;
  display: inline-flex; align-items: center; gap: 4px;
  padding: 6px 10px; background: var(--accent-dim); border-radius: 8px;
  transition: opacity 0.15s;
}
#panelDict a:active { opacity: 0.7; }
#panelDict { margin-bottom: 10px; }
.panel-actions {
  display: flex;
  gap: 8px;
}
.panel-btn {
  flex: 1;
  padding: 14px;
  border: none;
  border-radius: 12px;
  font-weight: 700;
  font-size: 14px;
  cursor: pointer;
  font-family: inherit;
  transition: all 0.12s;
}
.panel-btn:active { transform: scale(0.96); }
.btn-save { background: var(--accent); color: #fff; }
.btn-known { background: var(--green-dim); color: var(--green); border: 1px solid rgba(78,204,163,0.3); }
.btn-ignore { background: var(--surface2); color: var(--muted); border: 1px solid var(--border); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VOCAB LIST VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.search-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}
.search-input {
  flex: 1;
  padding: 12px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  outline: none;
}
.search-input:focus { border-color: var(--accent); }
.search-input::placeholder { color: var(--muted); }
.filter-chips {
  display: flex;
  gap: 6px;
  margin-bottom: 14px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 4px;
}
.chip {
  padding: 7px 14px;
  border-radius: 20px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--muted);
  font-size: 12px;
  font-weight: 500;
  font-family: inherit;
  white-space: nowrap;
  cursor: pointer;
  transition: all 0.12s;
}
.chip.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(233,69,96,0.3); }

.word-list { display: flex; flex-direction: column; gap: 6px; }
.word-card {
  display: flex;
  align-items: center;
  padding: 14px 16px;
  background: var(--surface);
  border-radius: var(--radius);
  gap: 12px;
  cursor: pointer;
  transition: background 0.12s;
}
.word-card:active { background: var(--surface2); }
.wc-word {
  font-size: 17px;
  font-weight: 700;
  color: var(--text);
  min-width: 0;
}
.wc-trans {
  flex: 1;
  font-size: 14px;
  color: var(--muted);
  text-align: right;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.wc-status {
  width: 8px; height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.wc-status.st-new { background: var(--blue); }
.wc-status.st-saved, .wc-status.st-learning { background: var(--yellow); }
.wc-status.st-known { background: var(--green); }
.wc-status.st-ignored { background: var(--muted); }

.empty-state {
  text-align: center;
  padding: 48px 20px;
  color: var(--muted);
}
.empty-state .big { font-size: 40px; margin-bottom: 12px; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATS VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-bottom: 20px;
}
.stat-card {
  background: var(--surface);
  border-radius: var(--radius);
  padding: 18px 16px;
  text-align: center;
}
.stat-num {
  font-size: 32px;
  font-weight: 800;
  font-family: 'JetBrains Mono', monospace;
}
.stat-num.c-accent { color: var(--accent); }
.stat-num.c-blue { color: var(--blue); }
.stat-num.c-yellow { color: var(--yellow); }
.stat-num.c-green { color: var(--green); }
.stat-label {
  font-size: 12px;
  color: var(--muted);
  margin-top: 4px;
}

.section-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 10px;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SETTINGS VIEW
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.settings-group {
  background: var(--surface);
  border-radius: var(--radius);
  overflow: hidden;
  margin-bottom: 16px;
}
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 14px 16px;
  border-bottom: 1px solid var(--border);
}
.settings-row:last-child { border-bottom: none; }
.settings-label {
  font-size: 15px;
  font-weight: 500;
}
.settings-desc {
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}
.toggle {
  position: relative;
  width: 48px; height: 28px;
  background: var(--surface3);
  border-radius: 14px;
  cursor: pointer;
  transition: background 0.2s;
  border: none;
}
.toggle::after {
  content: '';
  position: absolute;
  width: 22px; height: 22px;
  top: 3px; left: 3px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s;
}
.toggle.on { background: var(--green); }
.toggle.on::after { transform: translateX(20px); }
.action-btn {
  width: 100%;
  padding: 14px;
  border: none;
  border-radius: var(--radius);
  font-weight: 600;
  font-size: 15px;
  cursor: pointer;
  font-family: inherit;
  margin-bottom: 10px;
  transition: all 0.12s;
}
.action-btn:active { transform: scale(0.98); }
.action-btn.primary { background: var(--accent); color: #fff; }
.action-btn.secondary { background: var(--surface); color: var(--text); }
.action-btn.danger { background: rgba(233,69,96,0.15); color: var(--accent); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MODALS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.modal-overlay {
  position: fixed; inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 200;
  display: none;
  align-items: flex-end;
  justify-content: center;
}
.modal-overlay.show { display: flex; }
.modal {
  background: var(--surface);
  border-top-left-radius: 20px;
  border-top-right-radius: 20px;
  width: 100%;
  max-height: 85vh;
  overflow-y: auto;
  padding: 20px;
  padding-bottom: calc(var(--safe-bottom) + 20px);
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
}
.modal-overlay.show .modal { transform: translateY(0); }
.modal h2 {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 16px;
}
.modal textarea {
  width: 100%;
  min-height: 180px;
  padding: 14px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  resize: vertical;
  outline: none;
  margin-bottom: 12px;
}
.modal textarea:focus { border-color: var(--accent); }
.modal input[type="text"], .modal input[type="url"] {
  width: 100%;
  padding: 14px;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text);
  font-family: inherit;
  font-size: 15px;
  outline: none;
  margin-bottom: 12px;
}
.modal input:focus { border-color: var(--accent); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WORD DETAIL MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.detail-word {
  font-size: 28px;
  font-weight: 800;
  color: var(--accent);
}
.detail-trans {
  font-size: 18px;
  color: var(--green);
  margin-bottom: 12px;
}
.detail-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 14px;
}
.detail-badge {
  padding: 4px 10px;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
}
.detail-badge.b-status { background: var(--blue-dim); color: var(--blue); }
.detail-badge.b-encounters { background: var(--yellow-dim); color: var(--yellow); }
.detail-ctx-list {
  margin-top: 12px;
}
.detail-ctx-item {
  font-size: 13px;
  color: var(--muted);
  padding: 8px;
  background: var(--surface2);
  border-radius: 8px;
  margin-bottom: 6px;
  font-style: italic;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UTILITY
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.hidden { display: none !important; }
input[type="file"] { display: none; }

/* Loading spinner */
.spinner {
  display: inline-block;
  width: 18px; height: 18px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* Toast */
.toast {
  position: fixed;
  bottom: calc(var(--tab-h) + var(--safe-bottom) + 12px);
  left: 50%; transform: translateX(-50%) translateY(80px);
  background: var(--surface2);
  color: var(--green);
  border: 1px solid rgba(78,204,163,0.3);
  padding: 10px 20px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
  z-index: 300;
  opacity: 0;
  transition: all 0.3s;
  pointer-events: none;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

/* Scrollbar */
::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* Lesson cards */
.lesson-card { background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:12px 14px;margin-bottom:10px;cursor:pointer;transition:border-color .2s; }
.lesson-card:active { border-color:var(--accent); }
.lesson-card-title { font-weight:600;font-size:14px;margin-bottom:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; }
.lesson-card-meta { font-size:11px;color:var(--muted);display:flex;justify-content:space-between;align-items:center; }
.lesson-card-progress { display:flex;gap:8px;font-size:11px;margin-top:6px; }
.lesson-card-progress span { display:flex;align-items:center;gap:2px; }
.lesson-card-bar { height:4px;border-radius:2px;background:var(--surface2);margin-top:6px;overflow:hidden; }
.lesson-card-bar-fill { height:100%;border-radius:2px;transition:width .3s; }
.lesson-card-actions { display:flex;gap:6px;margin-top:8px; }
.lesson-card-actions button { flex:1;padding:6px;border:none;border-radius:8px;font-size:12px;font-weight:600;cursor:pointer; }
.lesson-btn-resume { background:var(--accent);color:#fff; }
.lesson-btn-delete { background:var(--surface2);color:var(--muted); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FLASHCARD MODE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.fc-setup { padding: 4px 0; }
.fc-setup-title { font-size: 16px; font-weight: 700; margin-bottom: 14px; display: flex; align-items: center; gap: 8px; }
.fc-option-group { background: var(--surface); border-radius: var(--radius); padding: 14px 16px; margin-bottom: 12px; }
.fc-option-label { font-size: 13px; font-weight: 600; color: var(--muted); margin-bottom: 8px; }
.fc-option-row { display: flex; gap: 6px; flex-wrap: wrap; }
.fc-chip {
  padding: 8px 14px; border-radius: 20px; background: var(--surface2); border: 1px solid var(--border);
  color: var(--muted); font-size: 13px; font-weight: 500; cursor: pointer; font-family: inherit; transition: all 0.12s;
}
.fc-chip.active { background: var(--accent-dim); color: var(--accent); border-color: rgba(233,69,96,0.3); }
.fc-start-btn {
  width: 100%; padding: 16px; border: none; border-radius: var(--radius); background: var(--accent); color: #fff;
  font-size: 16px; font-weight: 700; cursor: pointer; font-family: inherit; margin-top: 8px; transition: all 0.12s;
}
.fc-start-btn:active { transform: scale(0.98); }
.fc-start-btn:disabled { opacity: 0.4; }

/* Flashcard session */
.fc-session {
  display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 200; background: var(--bg);
  flex-direction: column; padding: 0;
}
.fc-session.active { display: flex; }
.fc-session-header {
  display: flex; align-items: center; justify-content: space-between; padding: 12px 16px;
  padding-top: calc(12px + var(--safe-top));
  border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.fc-progress-text { font-family: 'JetBrains Mono'; font-size: 13px; color: var(--muted); }
.fc-close { background: none; border: none; color: var(--muted); font-size: 22px; cursor: pointer; }
.fc-progress-bar { height: 3px; background: var(--surface2); flex-shrink: 0; }
.fc-progress-fill { height: 100%; background: var(--green); transition: width 0.3s; }

.fc-card-area {
  flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; overflow: hidden;
}
.fc-card {
  width: 100%; max-width: 360px; background: var(--surface); border-radius: 20px;
  padding: 32px 24px; text-align: center; cursor: pointer;
  box-shadow: 0 4px 24px rgba(0,0,0,0.15); transition: transform 0.15s;
  min-height: 200px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px;
}
.fc-card:active { transform: scale(0.98); }
.fc-card-word { font-size: 32px; font-weight: 800; color: var(--accent); }
.fc-card-hint { font-size: 13px; color: var(--muted); }
.fc-card-answer { font-size: 22px; font-weight: 600; color: var(--green); margin-top: 8px; }
.fc-card-ctx { font-size: 12px; color: var(--muted); font-style: italic; margin-top: 4px; max-width: 280px; }
.fc-speak-btn { background: none; border: none; font-size: 28px; cursor: pointer; margin-top: 4px; }

.fc-buttons {
  display: flex; gap: 8px; padding: 12px 16px; padding-bottom: calc(12px + var(--safe-bottom));
  flex-shrink: 0; border-top: 1px solid var(--border); background: var(--surface);
}
.fc-btn {
  flex: 1; padding: 14px 8px; border: none; border-radius: 12px;
  font-weight: 700; font-size: 13px; cursor: pointer; font-family: inherit; transition: all 0.12s;
  display: flex; flex-direction: column; align-items: center; gap: 2px;
}
.fc-btn:active { transform: scale(0.96); }
.fc-btn-again { background: rgba(233,69,96,0.15); color: var(--accent); }
.fc-btn-hard { background: var(--yellow-dim); color: var(--yellow); }
.fc-btn-good { background: var(--green-dim); color: var(--green); }
.fc-btn-easy { background: var(--blue-dim); color: var(--blue); }
.fc-btn span { font-size: 10px; font-weight: 400; opacity: 0.7; }
.fc-result { text-align: center; padding: 40px 20px; }
.fc-result-big { font-size: 48px; margin-bottom: 12px; }
.fc-result-text { font-size: 18px; font-weight: 600; margin-bottom: 6px; }
.fc-result-sub { font-size: 14px; color: var(--muted); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LEVEL SYSTEM
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.level-card {
  background: var(--surface); border-radius: 20px; padding: 24px;
  text-align: center; margin-bottom: 20px; position: relative; overflow: hidden;
}
.level-badge {
  width: 80px; height: 80px; border-radius: 50%; margin: 0 auto 12px;
  display: flex; align-items: center; justify-content: center;
  font-size: 36px; font-weight: 800;
  background: linear-gradient(135deg, var(--accent), var(--accent-dim));
  color: #fff; box-shadow: 0 4px 20px rgba(233,69,96,0.3);
}
.level-title { font-size: 18px; font-weight: 700; margin-bottom: 2px; }
.level-subtitle { font-size: 13px; color: var(--muted); margin-bottom: 14px; }
.level-xp-bar {
  height: 10px; background: var(--surface2); border-radius: 5px; overflow: hidden; margin-bottom: 6px;
}
.level-xp-fill {
  height: 100%; border-radius: 5px; transition: width 0.5s;
  background: linear-gradient(90deg, var(--accent), var(--green));
}
.level-xp-text { font-size: 12px; color: var(--muted); font-family: 'JetBrains Mono'; }
</style>
</head>
<body>

<div class="app">
  <!-- â•â• Header â•â• -->
  <div class="header">
    <div class="logo" id="logoBtn"><span id="logoText">Lang</span><b>Vault</b></div>
    <div class="header-actions">
      <button class="icon-btn" id="btnTheme" title="Toggle theme">â—‘</button>
    </div>
  </div>

  <!-- â•â• Views â•â• -->
  <div class="views">

    <!-- â”€â”€ HOME â”€â”€ -->
    <div class="view active" id="viewHome">
      <div class="home-view">
        <div class="home-hero">ğŸ“š</div>
        <div class="home-title"><b>Lang</b><span>Vault</span></div>
        <div class="home-sub">Learn vocabulary by reading.<br>Pick your target language:</div>
        <div class="lang-cards">
          <button class="lang-card" data-lang="ru">
            <span class="lang-card-flag">ğŸ‡·ğŸ‡º</span>
            <div class="lang-card-info">
              <div class="lang-card-name">Russian</div>
              <div class="lang-card-desc">Learn Russian through reading</div>
            </div>
            <span class="lang-card-arrow">â€º</span>
          </button>
          <button class="lang-card" data-lang="es">
            <span class="lang-card-flag">ğŸ‡ªğŸ‡¸</span>
            <div class="lang-card-info">
              <div class="lang-card-name">Spanish</div>
              <div class="lang-card-desc">Learn Spanish through reading</div>
            </div>
            <span class="lang-card-arrow">â€º</span>
          </button>
          <button class="lang-card" data-lang="fr">
            <span class="lang-card-flag">ğŸ‡«ğŸ‡·</span>
            <div class="lang-card-info">
              <div class="lang-card-name">French</div>
              <div class="lang-card-desc">Learn French through reading</div>
            </div>
            <span class="lang-card-arrow">â€º</span>
          </button>
        </div>
      </div>
    </div>

    <!-- â”€â”€ READER â”€â”€ -->
    <div class="view" id="viewReader">
      <div id="importArea" class="import-area">
        <h2 id="importHeading">Import text</h2>
        <div class="import-btns">
          <button class="import-btn" id="btnPaste"><span class="em">ğŸ“„</span> Paste text</button>
          <button class="import-btn" id="btnFile"><span class="em">ğŸ“‚</span> .txt file</button>
          <button class="import-btn" id="btnPdf"><span class="em">ğŸ“•</span> PDF</button>
          <button class="import-btn" id="btnYT"><span class="em">ğŸ¥</span> YouTube</button>
        </div>
        <input type="file" id="fileInput" accept=".txt">
        <input type="file" id="pdfInput" accept=".pdf">
        <div id="lessonList" style="margin-top:20px;"></div>
      </div>

      <div id="readerContent" class="reader-content">
        <div class="reader-top-bar">
          <span class="reader-label" id="readerLabel">Text</span>
          <span class="page-info" id="pageInfo">1 / 1</span>
          <button class="close-text" id="btnCloseText">Ã—</button>
        </div>
        <div class="reader-stats-bar">
          <span class="stat-new">ğŸ”µ <b id="countNew">0</b></span>
          <span class="stat-saved">ğŸŸ¡ <b id="countSaved">0</b></span>
          <span class="stat-known">âšª <b id="countKnown">0</b></span>
        </div>
        <div class="page-progress-bar"><div class="page-progress-fill" id="pageProgressFill" style="width:0%"></div></div>
        <div id="textBody"></div>
        <div class="page-nav">
          <button class="page-btn" id="btnPrevPage" disabled>â† Prev</button>
          <button class="page-btn next-btn" id="btnNextPage">Next â†’</button>
        </div>
      </div>
    </div>

    <!-- â”€â”€ VOCAB â”€â”€ -->
    <div class="view" id="viewVocab">
      <!-- Vocab mode toggle -->
      <div style="display:flex;gap:8px;margin-bottom:12px;">
        <button class="chip active" id="btnVocabList" style="flex:1;text-align:center;padding:10px;">ğŸ“– List</button>
        <button class="chip" id="btnVocabFlash" style="flex:1;text-align:center;padding:10px;">ğŸƒ Flashcards</button>
      </div>

      <!-- LIST MODE -->
      <div id="vocabListMode">
        <div class="search-bar">
          <input class="search-input" id="vocabSearch" placeholder="Search wordsâ€¦" type="text" autocomplete="off" autocapitalize="off" spellcheck="false">
        </div>
        <div class="filter-chips" id="filterChips">
          <button class="chip active" data-filter="all">All</button>
          <button class="chip" data-filter="new">New</button>
          <button class="chip" data-filter="saved">Saved</button>
          <button class="chip" data-filter="learning">Learning</button>
          <button class="chip" data-filter="known">Known</button>
          <button class="chip" data-filter="ignored">Ignored</button>
        </div>
        <div class="word-list" id="wordList"></div>
      </div>

      <!-- FLASHCARD SETUP -->
      <div id="vocabFlashMode" style="display:none;">
        <div class="fc-setup">
          <div class="fc-option-group">
            <div class="fc-option-label">ğŸ“š Source</div>
            <div class="fc-option-row" id="fcLessonChips">
              <button class="fc-chip active" data-lesson="all">Tout</button>
              <button class="fc-chip" data-lesson="saved">Saved</button>
              <button class="fc-chip" data-lesson="due">Due</button>
              <button class="fc-chip" data-lesson="known">Known</button>
            </div>
          </div>
          <div class="fc-option-group">
            <div class="fc-option-label">ğŸ”¢ Number of cards</div>
            <div class="fc-option-row" id="fcCountChips">
              <button class="fc-chip" data-count="10">10</button>
              <button class="fc-chip active" data-count="20">20</button>
              <button class="fc-chip" data-count="50">50</button>
              <button class="fc-chip" data-count="all">Tout</button>
            </div>
          </div>
          <div id="fcWordCount" style="text-align:center;font-size:13px;color:var(--muted);margin:8px 0;"></div>
          <button class="fc-start-btn" id="fcStartBtn">â–¶ Start review</button>
        </div>
      </div>
    </div>

    <!-- â”€â”€ STATS â”€â”€ -->
    <div class="view" id="viewStats">
      <!-- Level Card -->
      <div class="level-card" id="levelCard">
        <div class="level-badge" id="levelBadge">1</div>
        <div class="level-title" id="levelTitle">Beginner</div>
        <div class="level-subtitle" id="levelSubtitle">Level 1</div>
        <div class="level-xp-bar"><div class="level-xp-fill" id="levelXpFill" style="width:0%"></div></div>
        <div class="level-xp-text" id="levelXpText">0 / 10 000 known words</div>
      </div>

      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-num c-accent" id="statTotal">0</div>
          <div class="stat-label">Total Words</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-blue" id="statNew">0</div>
          <div class="stat-label">New</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-yellow" id="statLearning">0</div>
          <div class="stat-label">Learning</div>
        </div>
        <div class="stat-card">
          <div class="stat-num c-green" id="statKnown">0</div>
          <div class="stat-label">Known</div>
        </div>
      </div>
      <div class="section-title">Vocabulary Breakdown</div>
      <div id="progressBar" style="height:12px;border-radius:6px;background:var(--surface);overflow:hidden;margin-bottom:24px;">
        <div style="display:flex;height:100%;">
          <div id="prgNew" style="background:var(--blue);transition:width 0.3s"></div>
          <div id="prgLearning" style="background:var(--yellow);transition:width 0.3s"></div>
          <div id="prgKnown" style="background:var(--green);transition:width 0.3s"></div>
        </div>
      </div>
      <div class="section-title">Recent Activity</div>
      <div id="activityList" style="display:flex;flex-direction:column;gap:6px;"></div>
    </div>

    <!-- â”€â”€ SETTINGS â”€â”€ -->
    <div class="view" id="viewSettings">
      <div class="section-title">Display</div>
      <div class="settings-group">
        <div class="settings-row">
          <div>
            <div class="settings-label">Dark Mode</div>
            <div class="settings-desc">Switch between dark and light</div>
          </div>
          <button class="toggle on" id="toggleDark"></button>
        </div>
        <div class="settings-row">
          <div>
            <div class="settings-label">Font Size</div>
            <div class="settings-desc">Reader text size</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="icon-btn" id="fontMinus" style="width:32px;height:32px;font-size:16px;">âˆ’</button>
            <span id="fontSizeLabel" style="font-family:'JetBrains Mono';font-size:13px;min-width:32px;text-align:center;">18</span>
            <button class="icon-btn" id="fontPlus" style="width:32px;height:32px;font-size:16px;">+</button>
          </div>
        </div>
      </div>

      <div class="section-title">YouTube (optional)</div>
      <div style="font-size:12px;color:var(--muted);margin-bottom:8px;line-height:1.5;">
        If Invidious fails, you can deploy a Vercel backend as fallback.
      </div>
      <input type="url" id="vercelUrlInput" placeholder="https://rusvault-api.vercel.app" style="width:100%;padding:12px;background:var(--surface);border:1px solid var(--border);border-radius:10px;color:var(--text);font-family:inherit;font-size:14px;outline:none;margin-bottom:8px;">
      <button class="action-btn secondary" id="btnSaveVercel">ğŸ’¾ Save Vercel URL</button>

      <div class="section-title">Data</div>
      <button class="action-btn secondary" id="btnExport">ğŸ“¤ Export Database (JSON)</button>
      <button class="action-btn secondary" id="btnImport">ğŸ“¥ Import Database (JSON)</button>
      <input type="file" id="importDbInput" accept=".json">
      <button class="action-btn danger" id="btnClear">ğŸ—‘ Clear All Data</button>
      <button class="action-btn secondary" id="btnResetSW" style="margin-top:4px;">ğŸ”„ Reset Service Worker (if buggy)</button>

      <div style="margin-top:24px;text-align:center;color:var(--muted);font-size:12px;">
        LangVault PWA v2.0<br>
        Offline-first Â· No cloud Â· Your data stays local
      </div>
    </div>
  </div>

  <!-- â•â• Tab Bar â•â• -->
  <div class="tab-bar hidden">
    <button class="tab" data-view="viewReader">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
      Read
    </button>
    <button class="tab" data-view="viewVocab">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
      Vocab
    </button>
    <button class="tab" data-view="viewStats">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/></svg>
      Stats
    </button>
    <button class="tab" data-view="viewSettings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
      Settings
    </button>
  </div>
</div>

<!-- â•â• Flashcard Session (fullscreen overlay) â•â• -->
<div class="fc-session" id="fcSession">
  <div class="fc-session-header">
    <span class="fc-progress-text" id="fcProgressText">0 / 0</span>
    <button class="fc-close" id="fcCloseBtn">âœ•</button>
  </div>
  <div class="fc-progress-bar"><div class="fc-progress-fill" id="fcProgressFill" style="width:0%"></div></div>
  <div class="fc-card-area" id="fcCardArea">
    <div class="fc-card" id="fcCard">
      <div class="fc-card-word" id="fcWord">â€”</div>
      <button class="fc-speak-btn" id="fcSpeak">ğŸ”Š</button>
      <div class="fc-card-hint" id="fcHint">Tap to reveal</div>
      <div class="fc-card-answer" id="fcAnswer" style="display:none;">â€”</div>
      <div class="fc-card-ctx" id="fcCtx" style="display:none;"></div>
    </div>
  </div>
  <div class="fc-buttons" id="fcButtons" style="display:none;">
    <button class="fc-btn fc-btn-again" data-grade="0">Again<span>&lt;1m</span></button>
    <button class="fc-btn fc-btn-hard" data-grade="1">Hard<span id="fcHardInt">1j</span></button>
    <button class="fc-btn fc-btn-good" data-grade="2">Good<span id="fcGoodInt">3j</span></button>
    <button class="fc-btn fc-btn-easy" data-grade="3">Easy<span id="fcEasyInt">7j</span></button>
  </div>
</div>

<!-- â•â• Word Panel (bottom sheet) â•â• -->
<div class="word-panel-overlay" id="panelOverlay"></div>
<div class="word-panel" id="wordPanel">
  <div class="panel-handle"></div>
  <div class="panel-body">
    <div style="display:flex;align-items:center;gap:10px;">
      <div class="panel-word" id="panelWord" style="flex:1;">â€”</div>
      <button id="panelSpeak" style="background:none;border:none;font-size:24px;cursor:pointer;padding:4px;">ğŸ”Š</button>
    </div>
    <div class="panel-translation" id="panelTrans">â³</div>
    <div class="panel-alts" id="panelAlts"></div>
    <div class="panel-ctx" id="panelCtx"></div>
    <div class="panel-sent" id="panelSent"></div>
    <div id="panelDict" style="display:none;margin-top:6px;"></div>
    <div class="panel-actions">
      <button class="panel-btn btn-save" id="panelSave">ğŸ’¾ Save</button>
      <button class="panel-btn btn-known" id="panelKnown">âœ“ Known</button>
      <button class="panel-btn btn-ignore" id="panelIgnore">âœ— Ignore</button>
    </div>
  </div>
</div>

<!-- â•â• Paste Modal â•â• -->
<div class="modal-overlay" id="pasteModal">
  <div class="modal">
    <h2>ğŸ“„ Paste text</h2>
    <textarea id="pasteInput" placeholder="Paste your text hereâ€¦"></textarea>
    <input type="text" id="pasteTitle" placeholder="Title (optional)">
    <button class="action-btn primary" id="pasteSubmit">Open Text</button>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('pasteModal')">Cancel</button>
  </div>
</div>

<!-- â•â• YouTube Modal â•â• -->
<div class="modal-overlay" id="ytModal">
  <div class="modal">
    <h2>ğŸ¥ YouTube â†’ LangVault</h2>

    <div style="margin-bottom:14px;">
      <div style="font-size:14px;font-weight:600;margin-bottom:6px;">Option 1 â€” Paste URL</div>
      <input type="url" id="ytUrl" placeholder="https://youtube.com/watch?v=â€¦">
      <button class="action-btn primary" id="ytSubmitUrl" style="margin-bottom:0;">ğŸ” Fetch subtitles</button>
      <div id="ytStatus" style="font-size:12px;color:var(--muted);text-align:center;min-height:18px;margin-top:6px;"></div>
    </div>

    <div style="background:var(--surface2);border-radius:10px;padding:10px 12px;margin-bottom:10px;line-height:1.5;">
      <div style="font-size:13px;font-weight:600;margin-bottom:4px;">Option 2 â€” Manual paste</div>
      <div style="font-size:12px;color:var(--muted);">
        YouTube â†’ <b>â‹¯</b> under the video â†’ <b>Show transcript</b> â†’ Copy all â†’ Paste here â†“
      </div>
    </div>

    <textarea id="ytText" placeholder="Paste transcript hereâ€¦" style="min-height:120px;"></textarea>
    <input type="text" id="ytTitle" placeholder="Title (optional)">
    <button class="action-btn primary" id="ytSubmitText">ğŸ“„ Import text</button>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('ytModal')">Cancel</button>
  </div>
</div>

<!-- â•â• Word Detail Modal â•â• -->
<div class="modal-overlay" id="detailModal">
  <div class="modal">
    <div class="detail-word" id="detailWord">â€”</div>
    <div class="detail-trans" id="detailTrans">â€”</div>
    <div id="detailDict" style="margin:8px 0;"></div>
    <div class="detail-meta" id="detailMeta"></div>
    <div class="detail-ctx-list" id="detailContexts"></div>
    <div style="display:flex;gap:8px;margin-top:16px;">
      <button class="panel-btn btn-known" id="detailKnown" style="flex:1;">âœ“ Mark Known</button>
      <button class="panel-btn btn-ignore" id="detailDelete" style="flex:1;background:var(--accent-dim);color:var(--accent);">ğŸ—‘ Delete</button>
    </div>
    <button class="action-btn secondary" style="margin-top:8px" onclick="closeModal('detailModal')">Close</button>
  </div>
</div>

<!-- â•â• Toast â•â• -->
<div class="toast" id="toast"></div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LANGVAULT PWA â€” Multi-language vocabulary learning
   IndexedDB + Offline-first + LingQ-style reader
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

(function() {
'use strict';

// â”€â”€ Language Config â”€â”€
var LANG_CONFIG = {
  ru: {
    flag: 'ğŸ‡·ğŸ‡º',
    name: 'Russian',
    wordRegex: /([Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]+)/g,
    wordTest: /[Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]/,
    voicePrefix: 'ru',
    ttsLang: 'ru-RU',
    translateFrom: 'ru',
    translateTo: 'en',
    importLabel: 'Import Russian text',
    dbName: 'rusvault'
  },
  es: {
    flag: 'ğŸ‡ªğŸ‡¸',
    name: 'Spanish',
    wordRegex: /([a-zA-ZÃ¡Ã©Ã­Ã³ÃºÃ¼Ã±ÃÃ‰ÃÃ“ÃšÃœÃ‘'-]+)/g,
    wordTest: /[a-zA-ZÃ¡Ã©Ã­Ã³ÃºÃ¼Ã±ÃÃ‰ÃÃ“ÃšÃœÃ‘]/,
    voicePrefix: 'es',
    ttsLang: 'es-ES',
    translateFrom: 'es',
    translateTo: 'en',
    importLabel: 'Import Spanish text',
    dbName: 'langvault_es'
  },
  fr: {
    flag: 'ğŸ‡«ğŸ‡·',
    name: 'French',
    wordRegex: /([a-zA-ZÃ Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã§Å“Ã¦Ã€Ã‚Ã„Ã‰ÃˆÃŠÃ‹ÃÃÃ”Ã™Ã›ÃœÅ¸Ã‡Å’Ã†'-]+)/g,
    wordTest: /[a-zA-ZÃ Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã§Å“Ã¦Ã€Ã‚Ã„Ã‰ÃˆÃŠÃ‹ÃÃÃ”Ã™Ã›ÃœÅ¸Ã‡Å’Ã†]/,
    voicePrefix: 'fr',
    ttsLang: 'fr-FR',
    translateFrom: 'fr',
    translateTo: 'ru',
    importLabel: 'Import French text',
    dbName: 'langvault_fr'
  }
};

var currentLang = null;  // set when user picks a language
var WORD_REGEX = /([Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]+)/g;  // default fallback
var WORD_TEST = /[Ğ°-ÑĞ-Ğ¯Ñ‘Ğ]/;

function getLangConfig() { return LANG_CONFIG[currentLang] || LANG_CONFIG.ru; }

// Safari-compatible fetch timeout (no AbortController â€” uses Promise.race)
function fetchWithTimeout(url, opts, ms) {
  var timeout = new Promise(function(_, reject) {
    setTimeout(function() { reject(new Error('timeout')); }, ms || 8000);
  });
  return Promise.race([fetch(url, opts || {}), timeout]);
}
var DB_NAME = 'rusvault';
var DB_VERSION = 2;

// â”€â”€ State â”€â”€
let db = null;
let wordCache = new Map();
let currentWord = null;
let currentCtx = '';
let currentLessonId = null;
let settings = {
  darkMode: true,
  fontSize: 18
};

// â”€â”€ Ebook pagination state â”€â”€
let allChunks = [];           // text split into sentences/small chunks
let pages = [];               // array of arrays: each sub-array = chunk indices for that page
let currentPage = 0;

// â”€â”€ Preload TTS voices â”€â”€
let cachedVoice = null;
function preloadVoices() {
  if (!('speechSynthesis' in window)) return;
  var voices = speechSynthesis.getVoices();
  if (voices.length > 0 && currentLang) {
    var prefix = getLangConfig().voicePrefix;
    cachedVoice = voices.find(function(v) { return v.lang && v.lang.startsWith(prefix); }) || null;
  }
}
preloadVoices();
if ('speechSynthesis' in window && speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.onvoiceschanged = preloadVoices;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INDEXEDDB
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;

      if (!db.objectStoreNames.contains('words')) {
        const ws = db.createObjectStore('words', { keyPath: 'id', autoIncrement: true });
        ws.createIndex('word', 'word', { unique: false });
        ws.createIndex('wordLower', 'wordLower', { unique: false });
        ws.createIndex('status', 'status', { unique: false });
        ws.createIndex('createdAt', 'createdAt', { unique: false });
      }

      if (!db.objectStoreNames.contains('sources')) {
        const ss = db.createObjectStore('sources', { keyPath: 'id', autoIncrement: true });
        ss.createIndex('type', 'type', { unique: false });
      }

      if (!db.objectStoreNames.contains('lessons')) {
        const ls = db.createObjectStore('lessons', { keyPath: 'id', autoIncrement: true });
        ls.createIndex('createdAt', 'createdAt', { unique: false });
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(db); };
    req.onerror = (e) => reject(e.target.error);
  });
}

function tx(storeName, mode = 'readonly') {
  return db.transaction(storeName, mode).objectStore(storeName);
}

function dbGet(store, key) {
  return new Promise((res, rej) => {
    const r = tx(store).get(key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbGetAll(store) {
  return new Promise((res, rej) => {
    const r = tx(store).getAll();
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbPut(store, data) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').put(data);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbAdd(store, data) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').add(data);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

function dbDelete(store, key) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').delete(key);
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}

function dbClear(store) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').clear();
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}

function dbFindByIndex(store, indexName, value) {
  return new Promise((res, rej) => {
    const r = tx(store).index(indexName).getAll(value);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}

// â”€â”€ Load word cache (all words into memory for fast highlighting) â”€â”€
async function loadWordCache() {
  const all = await dbGetAll('words');
  wordCache.clear();
  for (const w of all) {
    wordCache.set(w.wordLower, w);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const tabs = document.querySelectorAll('.tab');
const views = document.querySelectorAll('.view');

tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    const target = tab.dataset.view;
    tabs.forEach(t => t.classList.remove('active'));
    views.forEach(v => v.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(target).classList.add('active');

    if (target === 'viewReader') renderLessonList();
    if (target === 'viewVocab') renderVocabList();
    if (target === 'viewStats') renderStats();
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THEME & SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function loadSettings() {
  try {
    const s = localStorage.getItem('rv_settings');
    if (s) settings = { ...settings, ...JSON.parse(s) };
  } catch (e) {}
  applySettings();
}

function saveSettings() {
  localStorage.setItem('rv_settings', JSON.stringify(settings));
}

function applySettings() {
  document.documentElement.setAttribute('data-theme', settings.darkMode ? 'dark' : 'light');
  document.getElementById('toggleDark').classList.toggle('on', settings.darkMode);
  document.getElementById('fontSizeLabel').textContent = settings.fontSize;
}

document.getElementById('btnTheme').addEventListener('click', () => {
  settings.darkMode = !settings.darkMode;
  applySettings(); saveSettings();
});

document.getElementById('toggleDark').addEventListener('click', () => {
  settings.darkMode = !settings.darkMode;
  applySettings(); saveSettings();
});

document.getElementById('fontMinus').addEventListener('click', () => {
  if (settings.fontSize > 12) { settings.fontSize -= 2; applySettings(); saveSettings(); updateReaderFont(); }
});
document.getElementById('fontPlus').addEventListener('click', () => {
  if (settings.fontSize < 30) { settings.fontSize += 2; applySettings(); saveSettings(); updateReaderFont(); }
});

function updateReaderFont() {
  var el = document.getElementById('textBody');
  if (el) {
    el.style.fontSize = settings.fontSize + 'px';
    // Re-paginate with new font size if in ebook mode
    if (allChunks.length > 0) {
      var lessonText = allChunks.join('\n');
      buildPages(lessonText);
      if (currentPage >= pages.length) currentPage = pages.length - 1;
      showPage(currentPage);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  READER â€” Import & Display
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Paste â”€â”€
document.getElementById('btnPaste').addEventListener('click', () => openModal('pasteModal'));
document.getElementById('pasteSubmit').addEventListener('click', () => {
  const text = document.getElementById('pasteInput').value.trim();
  if (!text) return;
  const title = document.getElementById('pasteTitle').value.trim() || 'Pasted text';
  currentLessonId = null;
  loadText(text, title);
  closeModal('pasteModal');
  document.getElementById('pasteInput').value = '';
  document.getElementById('pasteTitle').value = '';
});

// â”€â”€ File â”€â”€
document.getElementById('btnFile').addEventListener('click', () => {
  document.getElementById('fileInput').click();
});
document.getElementById('fileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    currentLessonId = null;
    loadText(ev.target.result, file.name);
  };
  reader.readAsText(file);
  e.target.value = '';
});

// â”€â”€ PDF â”€â”€
document.getElementById('btnPdf').addEventListener('click', () => {
  document.getElementById('pdfInput').click();
});
document.getElementById('pdfInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  showToast('ğŸ“• Extracting PDFâ€¦');

  try {
    var arrayBuffer = await file.arrayBuffer();
    if (typeof pdfjsLib === 'undefined') {
      showToast('âŒ PDF.js not loaded. Check your connection.');
      return;
    }
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    var pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    var fullText = '';

    for (var p = 1; p <= pdf.numPages; p++) {
      var page = await pdf.getPage(p);
      var content = await page.getTextContent();
      var pageText = content.items.map(function(item) { return item.str; }).join(' ');
      fullText += pageText + '\n';
    }

    fullText = fullText.trim();
    if (fullText.length < 10) {
      showToast('âŒ No text found in PDF');
      return;
    }

    currentLessonId = null;
    loadText(fullText, file.name.replace('.pdf', ''));
    showToast('âœ“ PDF imported ! (' + pdf.numPages + ' pages)');
  } catch (err) {
    console.error('[PDF]', err);
    showToast('âŒ PDF error: ' + err.message);
  }
  e.target.value = '';
});

// â”€â”€ YouTube â”€â”€
document.getElementById('btnYT').addEventListener('click', function() { openModal('ytModal'); });

// Option 1: Auto URL
document.getElementById('ytSubmitUrl').addEventListener('click', async function() {
  var url = document.getElementById('ytUrl').value.trim();
  var status = document.getElementById('ytStatus');
  if (!url) { showToast('Entre une URL YouTube'); return; }

  var videoId = extractYTId(url);
  if (!videoId) { showToast('âŒ URL invalide'); return; }

  status.textContent = 'â³ Searching for subtitlesâ€¦';

  try {
    var subs = await fetchYTSubtitles(videoId);
    if (subs && subs.length > 20) {
      var title = document.getElementById('ytTitle').value.trim() || 'YouTube: ' + videoId;
      currentLessonId = null;
      loadText(subs, title);
      closeModal('ytModal');
      document.getElementById('ytUrl').value = '';
      document.getElementById('ytTitle').value = '';
      status.textContent = '';
      showToast('âœ“ Subtitles imported !');
    } else {
      status.textContent = 'âš ï¸ No subtitles found. Try copy-paste instead.';
    }
  } catch (err) {
    console.error('[RusVault YT]', err);
    status.textContent = 'âš ï¸ ' + (err.message || 'Failed') + '. Try copy-paste instead.';
  }
});

// Option 2: Paste
document.getElementById('ytSubmitText').addEventListener('click', function() {
  var text = document.getElementById('ytText').value.trim();
  if (!text) { showToast('Colle du texte d\'abord'); return; }
  var title = document.getElementById('ytTitle').value.trim() || 'YouTube transcript';
  var cleaned = cleanTranscript(text);
  if (cleaned.length < 10) { showToast('Pas assez de texte'); return; }
  currentLessonId = null;
  loadText(cleaned, title);
  closeModal('ytModal');
  document.getElementById('ytText').value = '';
  document.getElementById('ytUrl').value = '';
  document.getElementById('ytTitle').value = '';
  document.getElementById('ytStatus').textContent = '';
});

function extractYTId(url) {
  var m = url.match(/(?:v=|youtu\.be\/|\/shorts\/)([a-zA-Z0-9_-]{11})/);
  return m ? m[1] : null;
}

async function fetchYTSubtitles(videoId) {
  var status = document.getElementById('ytStatus');

  // List of public Invidious instances with CORS enabled
  var instances = [
    'https://inv.nadeko.net',
    'https://invidious.nerdvpn.de',
    'https://invidious.jing.rocks',
    'https://invidious.privacyredirect.com',
    'https://invidious.protokolla.fi',
    'https://iv.datura.network',
    'https://invidious.perennialte.ch',
    'https://yt.drgnz.club'
  ];

  // Try fetching the instance list dynamically for freshness
  try {
    var listResp = await fetchWithTimeout('https://api.invidious.io/instances.json?sort_by=health', {}, 5000);
    if (listResp.ok) {
      var allInstances = await listResp.json();
      var fresh = allInstances
        .filter(function(entry) {
          var info = entry[1];
          return info && info.type === 'https' && info.api === true && info.cors === true;
        })
        .map(function(entry) { return entry[1].uri; })
        .slice(0, 12);
      if (fresh.length >= 3) instances = fresh;
    }
  } catch (e) { /* use hardcoded fallback */ }

  // Shuffle to spread load
  for (var s = instances.length - 1; s > 0; s--) {
    var r = Math.floor(Math.random() * (s + 1));
    var tmp = instances[s]; instances[s] = instances[r]; instances[r] = tmp;
  }

  for (var i = 0; i < instances.length; i++) {
    var base = instances[i];
    status.textContent = 'ğŸ” Attempt ' + (i + 1) + '/' + instances.length + 'â€¦';

    try {
      // Step 1: List available captions
      var listUrl = base + '/api/v1/captions/' + videoId;
      var capResp = await fetchWithTimeout(listUrl, {}, 6000);
      if (!capResp.ok) continue;
      var listData = await capResp.json();
      var captions = listData.captions || [];

      // Find caption in target language
      var targetLang = currentLang || 'ru';
      var langLabels = { ru: ['Ñ€ÑƒÑÑĞº', 'russian'], es: ['spanish', 'espaÃ±ol', 'espagn'], fr: ['french', 'franÃ§ais', 'franc'] };
      var target = null;
      for (var c = 0; c < captions.length; c++) {
        var cap = captions[c];
        var lc = (cap.language_code || cap.languageCode || '').toLowerCase();
        if (lc === targetLang || lc.startsWith(targetLang + '-')) {
          target = cap;
          break;
        }
      }

      if (!target) {
        var labels = langLabels[targetLang] || [targetLang];
        for (var c2 = 0; c2 < captions.length; c2++) {
          var label = (captions[c2].label || '').toLowerCase();
          for (var lb = 0; lb < labels.length; lb++) {
            if (label.indexOf(labels[lb]) !== -1) { target = captions[c2]; break; }
          }
          if (target) break;
        }
      }

      if (!target) continue;

      // Step 2: Fetch the actual subtitle text
      var subUrl = base + target.url;
      // Force VTT format
      if (subUrl.indexOf('?') === -1) subUrl += '?format=vtt';
      else subUrl += '&format=vtt';

      var subResp = await fetchWithTimeout(subUrl, {}, 8000);
      if (!subResp.ok) continue;
      var subText = await subResp.text();

      // Parse VTT to plain text
      var parsed = parseVTT(subText);
      if (parsed && parsed.length > 20) {
        status.textContent = 'ğŸ“ Subtitles found !';
        return parsed;
      }
    } catch (e) {
      continue;
    }
  }

  // Fallback: try Vercel backend if configured
  var vercelUrl = localStorage.getItem('rusvault_vercel_url');
  if (vercelUrl) {
    try {
      status.textContent = 'ğŸ”„ Attempt via Vercel backendâ€¦';
      vercelUrl = vercelUrl.replace(/\/+$/, '');
      var vResp = await fetchWithTimeout(vercelUrl + '/api/subs?v=' + videoId + '&lang=' + (currentLang || 'ru'), {}, 25000);
      if (vResp.ok) {
        var vData = await vResp.json();
        if (vData.ok && vData.text && vData.text.length > 20) {
          status.textContent = 'ğŸ“ Found via Vercel !';
          return vData.text;
        }
      }
    } catch (e) { /* Vercel also failed */ }
  }

  throw new Error('No instance could\'fetch subtitles');
}

// Parse VTT subtitle format to plain text
function parseVTT(vtt) {
  return vtt
    .split('\n')
    .filter(function(line) {
      // Remove timestamps, headers, empty lines
      if (!line.trim()) return false;
      if (line.indexOf('-->') !== -1) return false;
      if (line.match(/^WEBVTT/)) return false;
      if (line.match(/^Kind:|^Language:/)) return false;
      if (line.match(/^\d+$/)) return false;
      return true;
    })
    .map(function(line) {
      // Remove VTT tags like <c>, </c>, timestamps in cues
      return line.replace(/<[^>]+>/g, '').replace(/&nbsp;/g, ' ').trim();
    })
    .filter(function(line) { return line.length > 0; })
    // Remove consecutive duplicate lines (common in auto-subs)
    .filter(function(line, idx, arr) { return idx === 0 || line !== arr[idx - 1]; })
    .join(' ')
    .replace(/\s{2,}/g, ' ')
    .trim();
}

function cleanTranscript(text) {
  return text
    .replace(/\d{1,2}:\d{2}(:\d{2})?/g, '')
    .replace(/\[.*?\]/g, '')
    .replace(/\n{2,}/g, '\n')
    .trim()
    .split('\n')
    .map(function(l) { return l.trim(); })
    .filter(function(l) { return l.length > 0; })
    .join(' ')
    .replace(/\s{2,}/g, ' ');
}

// â”€â”€ Load text into reader â”€â”€
async function loadText(text, title, startPage) {
  document.getElementById('importArea').style.display = 'none';
  const rc = document.getElementById('readerContent');
  rc.classList.add('has-text');
  document.getElementById('readerLabel').textContent = title || 'Text';

  buildPages(text);
  currentPage = Math.min(startPage || 0, pages.length - 1);
  if (currentPage < 0) currentPage = 0;
  showPage(currentPage);

  // Save as lesson
  if (!currentLessonId) {
    var now = new Date().toISOString();
    var lesson = {
      title: title || 'Text',
      text: text,
      createdAt: now,
      lastOpenedAt: now,
      currentPage: 0
    };
    var id = await dbAdd('lessons', lesson);
    currentLessonId = id;
  } else {
    try {
      var les = await dbGet('lessons', currentLessonId);
      if (les) {
        les.lastOpenedAt = new Date().toISOString();
        await dbPut('lessons', les);
      }
    } catch (e) {}
  }

  // Setup swipe gestures
  setupSwipe();
}

function openLesson(lesson) {
  currentLessonId = lesson.id;
  loadText(lesson.text, lesson.title, lesson.currentPage || 0);
}

async function deleteLesson(id) {
  return new Promise(function(resolve, reject) {
    var t = db.transaction('lessons', 'readwrite');
    var req = t.objectStore('lessons').delete(id);
    req.onsuccess = function() { resolve(); };
    req.onerror = function(e) { reject(e.target.error); };
  });
}

async function renderLessonList() {
  var container = document.getElementById('lessonList');
  var lessons = await dbGetAll('lessons');
  
  if (lessons.length === 0) {
    container.innerHTML = '';
    return;
  }

  // Sort by lastOpenedAt descending
  lessons.sort(function(a, b) {
    return (b.lastOpenedAt || b.createdAt).localeCompare(a.lastOpenedAt || a.createdAt);
  });

  var html = '<div style="font-size:14px;font-weight:700;margin-bottom:10px;">ğŸ“š My lessons</div>';

  for (var i = 0; i < lessons.length; i++) {
    var l = lessons[i];
    // Count word stats for this lesson
    var words = l.text.match(WORD_REGEX) || [];
    var uniqueWords = {};
    for (var j = 0; j < words.length; j++) {
      uniqueWords[words[j].toLowerCase()] = true;
    }
    var unique = Object.keys(uniqueWords);
    var newC = 0, knownC = 0, savedC = 0;
    for (var k = 0; k < unique.length; k++) {
      var cached = wordCache.get(unique[k]);
      if (!cached) newC++;
      else if (cached.status === 'known' || cached.status === 'ignored') knownC++;
      else savedC++;
    }
    var total = unique.length || 1;
    var pctKnown = Math.round((knownC / total) * 100);
    var pctSaved = Math.round((savedC / total) * 100);

    var dateStr = '';
    try {
      var d = new Date(l.lastOpenedAt || l.createdAt);
      dateStr = d.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
    } catch (e) {}

    html += '<div class="lesson-card" data-lesson-id="' + l.id + '">';
    html += '<div class="lesson-card-title">' + escHtml(l.title) + '</div>';
    html += '<div class="lesson-card-meta"><span>' + dateStr + '</span><span>' + unique.length + ' words</span></div>';
    var pageLabel = (l.currentPage > 0) ? ' Â· p.' + (l.currentPage + 1) : '';
    html += '<div class="lesson-card-progress">';
    html += '<span>ğŸ”µ ' + newC + '</span>';
    html += '<span>ğŸŸ¡ ' + savedC + '</span>';
    html += '<span>âšª ' + knownC + '</span>';
    html += '<span style="margin-left:auto;font-weight:600;">' + pctKnown + '%' + pageLabel + '</span>';
    html += '</div>';
    html += '<div class="lesson-card-bar"><div class="lesson-card-bar-fill" style="width:' + pctKnown + '%;background:var(--green);"></div></div>';
    html += '<div class="lesson-card-actions">';
    html += '<button class="lesson-btn-resume" data-resume="' + l.id + '">â–¶ Resume</button>';
    html += '<button class="lesson-btn-delete" data-del="' + l.id + '">ğŸ—‘</button>';
    html += '</div>';
    html += '</div>';
  }

  container.innerHTML = html;

  // Event listeners
  container.querySelectorAll('[data-resume]').forEach(function(btn) {
    btn.addEventListener('click', async function(e) {
      e.stopPropagation();
      var id = parseInt(this.dataset.resume);
      var lesson = await dbGet('lessons', id);
      if (lesson) openLesson(lesson);
    });
  });

  container.querySelectorAll('[data-del]').forEach(function(btn) {
    btn.addEventListener('click', async function(e) {
      e.stopPropagation();
      var id = parseInt(this.dataset.del);
      if (confirm('Delete this lesson?')) {
        await deleteLesson(id);
        renderLessonList();
        showToast('Lesson deleted');
      }
    });
  });
}

function escHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

document.getElementById('btnCloseText').addEventListener('click', () => {
  document.getElementById('importArea').style.display = '';
  document.getElementById('readerContent').classList.remove('has-text');
  document.getElementById('textBody').innerHTML = '';
  currentLessonId = null;
  allChunks = [];
  pages = [];
  currentPage = 0;
  renderLessonList();
});

// â”€â”€ Build pages from text â”€â”€
// â”€â”€ Split text into fine-grained chunks (sentences) â”€â”€
function splitIntoChunks(text) {
  var paragraphs = text.split(/\n+/).filter(function(p) { return p.trim().length > 0; });
  var chunks = [];
  for (var i = 0; i < paragraphs.length; i++) {
    var para = paragraphs[i].trim();
    // Split long paragraphs into sentences (keep punctuation with sentence)
    var sentences = para.match(/[^.!?â€¦]+[.!?â€¦]+[\s]*/g);
    if (sentences && sentences.length > 1) {
      for (var s = 0; s < sentences.length; s++) {
        var sent = sentences[s].trim();
        if (sent.length > 0) chunks.push(sent);
      }
    } else {
      // Short paragraph or no sentence-ending punctuation â€” keep as-is
      chunks.push(para);
    }
  }
  return chunks;
}

// â”€â”€ Build pages dynamically using real overflow detection â”€â”€
function buildPages(text) {
  allChunks = splitIntoChunks(text);
  pages = [];

  if (allChunks.length === 0) {
    pages = [[0]];
    return;
  }

  var body = document.getElementById('textBody');
  body.style.fontSize = settings.fontSize + 'px';
  body.style.lineHeight = '1.75';

  var chunkIndex = 0;
  while (chunkIndex < allChunks.length) {
    var pageChunks = [];
    body.innerHTML = '';

    // Add chunks one by one until it overflows
    while (chunkIndex < allChunks.length) {
      // Render test paragraph
      var testP = document.createElement('p');
      testP.textContent = allChunks[chunkIndex];
      body.appendChild(testP);

      // Check overflow
      if (pageChunks.length > 0 && body.scrollHeight > body.clientHeight) {
        // This chunk caused overflow â€” remove it, belongs to next page
        body.removeChild(testP);
        break;
      }

      pageChunks.push(chunkIndex);
      chunkIndex++;
    }

    // Safety: if one single chunk is too big, still put it on a page
    if (pageChunks.length === 0 && chunkIndex < allChunks.length) {
      pageChunks.push(chunkIndex);
      chunkIndex++;
    }

    pages.push(pageChunks);
  }

  body.innerHTML = '';
  if (pages.length === 0) pages = [[0]];
}

// â”€â”€ Show a specific page (ebook style â€” no scroll) â”€â”€
function showPage(pageIndex) {
  currentPage = pageIndex;
  var body = document.getElementById('textBody');

  // Page turn animation
  body.classList.remove('page-visible');
  body.classList.add('page-turning');

  setTimeout(function() {
    body.innerHTML = '';
    body.style.fontSize = settings.fontSize + 'px';
    body.style.lineHeight = '1.75';

    var chunkIndices = pages[currentPage] || [];
    var newCount = 0, savedCount = 0, knownCount = 0;

    for (var i = 0; i < chunkIndices.length; i++) {
      var chunkText = allChunks[chunkIndices[i]] || '';
      if (!chunkText.trim()) continue;

      var p = document.createElement('p');

      var parts = chunkText.split(WORD_REGEX);
      for (var j = 0; j < parts.length; j++) {
        var part = parts[j];
        if (!part) continue;

        if (WORD_TEST.test(part) && part.match(/^\S+$/)) {
          var lower = part.toLowerCase();
          var span = document.createElement('span');
          span.className = 'w';
          span.textContent = part;
          span.dataset.w = lower;

          var cached = wordCache.get(lower);
          if (cached) {
            if (cached.status === 'known') { span.classList.add('w-known'); knownCount++; }
            else if (cached.status === 'ignored') { span.classList.add('w-ignored'); }
            else { span.classList.add('w-saved'); savedCount++; }
          } else {
            span.classList.add('w-new');
            newCount++;
          }
          span.addEventListener('click', onWordTap);
          p.appendChild(span);
        } else {
          p.appendChild(document.createTextNode(part));
        }
      }
      body.appendChild(p);
    }

    document.getElementById('countNew').textContent = newCount;
    document.getElementById('countSaved').textContent = savedCount;
    document.getElementById('countKnown').textContent = knownCount;

    updatePageNav();
    body.classList.remove('page-turning');
    body.classList.add('page-visible');
  }, 80);

  savePagePosition();
}

// â”€â”€ Update page nav UI â”€â”€
function updatePageNav() {
  var total = pages.length;
  document.getElementById('pageInfo').textContent = (currentPage + 1) + ' / ' + total;
  document.getElementById('btnPrevPage').disabled = (currentPage <= 0);

  var nextBtn = document.getElementById('btnNextPage');
  if (currentPage >= total - 1) {
    nextBtn.textContent = 'âœ… Fin';
    nextBtn.disabled = false;  // Keep clickable to finish lesson
    nextBtn.classList.remove('next-btn');
    nextBtn.style.background = 'var(--green)';
    nextBtn.style.color = '#fff';
    nextBtn.style.borderColor = 'var(--green)';
  } else {
    nextBtn.textContent = 'Next â†’';
    nextBtn.disabled = false;
    nextBtn.classList.add('next-btn');
    nextBtn.style.background = '';
    nextBtn.style.color = '';
    nextBtn.style.borderColor = '';
  }

  var pct = total > 1 ? ((currentPage + 1) / total * 100) : 100;
  document.getElementById('pageProgressFill').style.width = pct + '%';
}

// â”€â”€ Re-color words on current page â”€â”€
function recolorWords() {
  let newC = 0, savedC = 0, knownC = 0;
  document.querySelectorAll('#textBody .w').forEach(span => {
    const lower = span.dataset.w;
    const cached = wordCache.get(lower);
    span.className = 'w';
    if (cached) {
      if (cached.status === 'known') { span.classList.add('w-known'); knownC++; }
      else if (cached.status === 'ignored') { span.classList.add('w-ignored'); }
      else { span.classList.add('w-saved'); savedC++; }
    } else {
      span.classList.add('w-new');
      newC++;
    }
  });
  document.getElementById('countNew').textContent = newC;
  document.getElementById('countSaved').textContent = savedC;
  document.getElementById('countKnown').textContent = knownC;
}

// â”€â”€ Auto-mark blue words as known on current page â”€â”€
async function autoMarkPageBlueWords() {
  var blueWords = document.querySelectorAll('#textBody .w.w-new');
  if (blueWords.length === 0) return 0;

  var seen = {};
  var toMark = [];
  for (var i = 0; i < blueWords.length; i++) {
    var w = blueWords[i].dataset.w;
    if (!seen[w]) { seen[w] = true; toMark.push(w); }
  }

  var now = new Date().toISOString();
  for (var j = 0; j < toMark.length; j++) {
    var word = toMark[j];
    var existing = wordCache.get(word);
    if (existing) {
      existing.status = 'known';
      existing.lastSeen = now;
      await dbPut('words', existing);
      wordCache.set(word, existing);
    } else {
      var entry = {
        word: word, wordLower: word, translation: '', status: 'known',
        encounters: 1, contexts: [], createdAt: now, lastSeen: now
      };
      var id = await dbAdd('words', entry);
      entry.id = id;
      wordCache.set(word, entry);
    }
  }
  return toMark.length;
}

// â”€â”€ Save page position to lesson â”€â”€
async function savePagePosition() {
  if (!currentLessonId) return;
  try {
    var les = await dbGet('lessons', currentLessonId);
    if (les) {
      les.currentPage = currentPage;
      les.lastOpenedAt = new Date().toISOString();
      await dbPut('lessons', les);
    }
  } catch (e) {}
}

// â”€â”€ Page navigation â”€â”€
document.getElementById('btnNextPage').addEventListener('click', async function() {
  var count = await autoMarkPageBlueWords();
  if (count > 0) showToast('âœ“ ' + count + ' word' + (count > 1 ? 's' : '') + ' â†’ known');

  if (currentPage >= pages.length - 1) {
    // Last page â€” finish lesson
    showToast('ğŸ‰ Lesson complete!');
    setTimeout(function() {
      document.getElementById('importArea').style.display = '';
      document.getElementById('readerContent').classList.remove('has-text');
      document.getElementById('textBody').innerHTML = '';
      currentLessonId = null;
      allChunks = [];
      pages = [];
      currentPage = 0;
      renderLessonList();
      renderVocabList();
    }, 800);
    return;
  }

  showPage(currentPage + 1);
});

document.getElementById('btnPrevPage').addEventListener('click', function() {
  if (currentPage <= 0) return;
  showPage(currentPage - 1);
});

// â”€â”€ Swipe gestures for page turning â”€â”€
function setupSwipe() {
  var body = document.getElementById('textBody');
  var startX = 0, startY = 0, swiping = false;

  body.addEventListener('touchstart', function(e) {
    if (e.touches.length !== 1) return;
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    swiping = true;
  }, { passive: true });

  body.addEventListener('touchend', async function(e) {
    if (!swiping) return;
    swiping = false;
    var endX = e.changedTouches[0].clientX;
    var endY = e.changedTouches[0].clientY;
    var dx = endX - startX;
    var dy = endY - startY;

    // Only count horizontal swipes (dx > 60px and more horizontal than vertical)
    if (Math.abs(dx) < 60 || Math.abs(dy) > Math.abs(dx)) return;

    if (dx < 0 && currentPage < pages.length - 1) {
      // Swipe left = next page
      var count = await autoMarkPageBlueWords();
      if (count > 0) showToast('âœ“ ' + count + ' word' + (count > 1 ? 's' : '') + ' â†’ known');
      showPage(currentPage + 1);
    } else if (dx > 0 && currentPage > 0) {
      // Swipe right = previous page
      showPage(currentPage - 1);
    }
  }, { passive: true });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORD TAP â†’ Panel
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function onWordTap(e) {
  e.preventDefault();
  e.stopPropagation();
  const span = e.currentTarget;
  const word = span.dataset.w;

  // Highlight
  document.querySelectorAll('.w.w-active').forEach(el => el.classList.remove('w-active'));
  span.classList.add('w-active');

  // Get context sentence
  let ctx = '';
  const par = span.closest('p');
  if (par) {
    ctx = par.textContent.trim();
    if (ctx.length > 300) ctx = ctx.substring(0, 300) + 'â€¦';
  }

  currentWord = word;
  currentCtx = ctx;

  showWordPanel(word, ctx);
  speakWord(word);
}

function showWordPanel(word, ctx) {
  const panel = document.getElementById('wordPanel');
  const overlay = document.getElementById('panelOverlay');

  document.getElementById('panelWord').textContent = word;
  document.getElementById('panelTrans').innerHTML = '<span class="spinner"></span>';
  document.getElementById('panelAlts').innerHTML = '';
  document.getElementById('panelDict').style.display = 'none';
  document.getElementById('panelDict').innerHTML = '';
  document.getElementById('panelCtx').textContent = ctx ? `Â« ${ctx} Â»` : '';
  document.getElementById('panelSent').style.display = 'none';
  document.getElementById('panelSent').textContent = '';

  overlay.classList.add('show');
  panel.classList.add('show');

  // Check if word already in DB
  const cached = wordCache.get(word);
  if (cached) {
    document.getElementById('panelSave').textContent = 'ğŸ“ Update';
    if (cached.translation) {
      document.getElementById('panelTrans').textContent = cached.translation;
    }
  } else {
    document.getElementById('panelSave').textContent = 'ğŸ’¾ Save';
  }

  // Fetch translation (offline: use cached; online: try Google Translate)
  fetchTranslation(word, ctx);
}

function hideWordPanel() {
  document.getElementById('wordPanel').classList.remove('show');
  document.getElementById('panelOverlay').classList.remove('show');
  document.querySelectorAll('.w.w-active').forEach(el => el.classList.remove('w-active'));
  currentWord = null;
}

document.getElementById('panelOverlay').addEventListener('click', hideWordPanel);

// â”€â”€ Pronunciation â”€â”€
document.getElementById('panelSpeak').addEventListener('click', function(e) {
  e.stopPropagation();
  if (!currentWord) return;
  speakWord(currentWord);
});

function speakWord(word) {
  if (!word) return;
  var cfg = getLangConfig();
  if ('speechSynthesis' in window) {
    speechSynthesis.cancel();
    var u = new SpeechSynthesisUtterance(word);
    u.lang = cfg.ttsLang;
    u.rate = 0.85;
    if (cachedVoice) {
      u.voice = cachedVoice;
    } else {
      var voices = speechSynthesis.getVoices();
      var voice = voices.find(function(v) { return v.lang && v.lang.startsWith(cfg.voicePrefix); });
      if (voice) { u.voice = voice; cachedVoice = voice; }
    }
    var spoke = false;
    u.onstart = function() { spoke = true; };
    u.onerror = function() { if (!spoke) playTTSFallback(word); };
    speechSynthesis.speak(u);
    setTimeout(function() {
      if (!spoke && !speechSynthesis.speaking) { speechSynthesis.cancel(); playTTSFallback(word); }
    }, 500);
    return;
  }
  playTTSFallback(word);
}

function playTTSFallback(word) {
  var tl = currentLang || 'ru';
  var audio = new Audio('https://translate.googleapis.com/translate_tts?ie=UTF-8&client=gtx&tl=' + tl + '&q=' + encodeURIComponent(word));
  audio.volume = 1.0;
  audio.play().catch(function() {});
}

// â”€â”€ Translation â”€â”€
async function fetchTranslation(word, sentence) {
  var cfg = getLangConfig();
  var sl = cfg.translateFrom;
  var tl = cfg.translateTo;
  var translation = '';
  var altsHtml = '';

  // Strategy 1: Google Translate direct (fastest, most reliable)
  try {
    var gp = 'client=gtx&sl=' + sl + '&tl=' + tl + '&dt=t&dt=bd&q=' + encodeURIComponent(word);
    var gr = await fetchWithTimeout('https://translate.googleapis.com/translate_a/single?' + gp, {}, 5000);
    var gd = await gr.json();
    if (gd && gd[0]) {
      for (var gi = 0; gi < gd[0].length; gi++) {
        if (gd[0][gi] && gd[0][gi][0]) translation += gd[0][gi][0];
      }
    }
    if (gd && gd[1]) {
      for (var ai = 0; ai < gd[1].length; ai++) {
        var entry = gd[1][ai];
        if (entry[0]) altsHtml += '<b>' + entry[0] + '</b> ';
        if (entry[1]) altsHtml += entry[1].slice(0, 4).join(', ');
        altsHtml += '<br>';
      }
    }
  } catch (e) { console.log('[LV] Google Translate failed:', e.message); }

  // Strategy 2: MyMemory (free, 5000 words/day)
  if (!translation) {
    try {
      var mmUrl = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(word) + '&langpair=' + sl + '|' + tl;
      var mr = await fetchWithTimeout(mmUrl, {}, 5000);
      if (mr.ok) {
        var md = await mr.json();
        if (md.responseData && md.responseData.translatedText) {
          translation = md.responseData.translatedText;
        }
        if (md.matches && md.matches.length > 1) {
          var seen = {};
          for (var mi = 0; mi < Math.min(md.matches.length, 5); mi++) {
            var mt = md.matches[mi].translation;
            if (mt && !seen[mt] && mt !== translation) {
              seen[mt] = true;
              altsHtml += mt + ', ';
            }
          }
          if (altsHtml && !altsHtml.includes('<b>')) altsHtml = altsHtml.slice(0, -2);
        }
      }
    } catch (e) { console.log('[LV] MyMemory failed:', e.message); }
  }

  // Strategy 3: Lingva (community proxies, often down â€” last resort)
  if (!translation) {
    var lingvaInstances = ['https://lingva.thedaviddelta.com', 'https://lingva.ml'];
    for (var li = 0; li < lingvaInstances.length; li++) {
      try {
        var lUrl = lingvaInstances[li] + '/api/v1/' + sl + '/' + tl + '/' + encodeURIComponent(word);
        var lr = await fetchWithTimeout(lUrl, {}, 3000);
        if (lr.ok) {
          var ld = await lr.json();
          if (ld.translation) { translation = ld.translation; break; }
        }
      } catch (e) { /* try next */ }
    }
  }

  // Update UI
  document.getElementById('panelTrans').textContent = translation || 'â€”';
  document.getElementById('panelTrans').dataset.value = translation || '';
  if (altsHtml) {
    document.getElementById('panelAlts').innerHTML = altsHtml;
  }

  // Dictionary link
  var dictEl = document.getElementById('panelDict');
  if (dictEl) {
    if (currentLang === 'ru') {
      dictEl.innerHTML = '<a href="https://en.openrussian.org/ru/' + encodeURIComponent(word) + '" target="_blank" rel="noopener">ğŸ“– OpenRussian â€” base form, accent, declension</a>';
    } else {
      dictEl.innerHTML = '<a href="https://en.wiktionary.org/wiki/' + encodeURIComponent(word) + '" target="_blank" rel="noopener">ğŸ“– Wiktionary â€” full entry</a>';
    }
    dictEl.style.display = 'block';
  }

  // Sentence translation
  if (sentence && sentence.length > word.length + 5) {
    var sq = sentence.substring(0, 300);
    var sentTrans = '';
    try {
      var sgp = 'client=gtx&sl=' + sl + '&tl=' + tl + '&dt=t&q=' + encodeURIComponent(sq);
      var sgr = await fetchWithTimeout('https://translate.googleapis.com/translate_a/single?' + sgp, {}, 5000);
      var sgd = await sgr.json();
      if (sgd && sgd[0]) {
        for (var sgi = 0; sgi < sgd[0].length; sgi++) {
          if (sgd[0][sgi] && sgd[0][sgi][0]) sentTrans += sgd[0][sgi][0];
        }
      }
    } catch (e) {}
    if (!sentTrans) {
      try {
        var smUrl = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(sq) + '&langpair=' + sl + '|' + tl;
        var smr = await fetchWithTimeout(smUrl, {}, 5000);
        if (smr.ok) {
          var smd = await smr.json();
          if (smd.responseData && smd.responseData.translatedText) sentTrans = smd.responseData.translatedText;
        }
      } catch (e) {}
    }
    if (sentTrans) {
      document.getElementById('panelSent').textContent = 'ğŸ“– ' + sentTrans;
      document.getElementById('panelSent').style.display = 'block';
    }
  }
}

// â”€â”€ Save / Known / Ignore â”€â”€
document.getElementById('panelSave').addEventListener('click', () => saveWord('saved'));
document.getElementById('panelKnown').addEventListener('click', () => saveWord('known'));
document.getElementById('panelIgnore').addEventListener('click', () => saveWord('ignored'));

async function saveWord(status) {
  if (!currentWord) return;
  const word = currentWord;
  const translation = document.getElementById('panelTrans').dataset.value || '';
  const now = new Date().toISOString();

  const existing = wordCache.get(word);

  if (existing) {
    // Update
    existing.status = status;
    existing.encounters = (existing.encounters || 1) + 1;
    existing.lastSeen = now;
    if (translation && !existing.translation) existing.translation = translation;
    if (currentCtx && !existing.contexts?.includes(currentCtx)) {
      existing.contexts = existing.contexts || [];
      if (existing.contexts.length < 10) existing.contexts.push(currentCtx);
    }
    await dbPut('words', existing);
    wordCache.set(word, existing);
  } else {
    // New
    const entry = {
      word: word,
      wordLower: word,
      translation: translation,
      status: status,
      encounters: 1,
      contexts: currentCtx ? [currentCtx] : [],
      createdAt: now,
      lastSeen: now
    };
    const id = await dbAdd('words', entry);
    entry.id = id;
    wordCache.set(word, entry);
  }

  const label = status === 'known' ? 'âœ“ Known' : status === 'ignored' ? 'âœ— Ignored' : 'âœ“ Saved';
  showToast(`${label}: ${word}`);
  hideWordPanel();
  recolorWords();
}

// (Auto-mark on page turn replaces the old "finish lesson" button)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VOCAB LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let vocabFilter = 'all';
let vocabQuery = '';

document.querySelectorAll('#filterChips .chip').forEach(chip => {
  chip.addEventListener('click', () => {
    document.querySelectorAll('#filterChips .chip').forEach(c => c.classList.remove('active'));
    chip.classList.add('active');
    vocabFilter = chip.dataset.filter;
    renderVocabList();
  });
});

document.getElementById('vocabSearch').addEventListener('input', (e) => {
  vocabQuery = e.target.value.toLowerCase().trim();
  renderVocabList();
});

async function renderVocabList() {
  const list = document.getElementById('wordList');
  let words = await dbGetAll('words');

  // Filter
  if (vocabFilter !== 'all') {
    words = words.filter(w => w.status === vocabFilter);
  }
  if (vocabQuery) {
    words = words.filter(w =>
      w.word.includes(vocabQuery) ||
      (w.translation && w.translation.toLowerCase().includes(vocabQuery))
    );
  }

  // Sort by newest first
  words.sort((a, b) => (b.createdAt || '').localeCompare(a.createdAt || ''));

  if (words.length === 0) {
    list.innerHTML = '<div class="empty-state"><div class="big">ğŸ“š</div>No words yet.<br>Start reading to build your vocabulary!</div>';
    return;
  }

  list.innerHTML = words.map(w => `
    <div class="word-card" data-id="${w.id}">
      <div class="wc-status st-${w.status || 'new'}"></div>
      <div class="wc-word">${escHtml(w.word)}</div>
      <div class="wc-trans">${escHtml(w.translation || '')}</div>
    </div>
  `).join('');

  list.querySelectorAll('.word-card').forEach(card => {
    card.addEventListener('click', () => showWordDetail(+card.dataset.id));
  });
}

async function showWordDetail(id) {
  const w = await dbGet('words', id);
  if (!w) return;

  document.getElementById('detailWord').textContent = w.word;
  document.getElementById('detailTrans').textContent = w.translation || 'â³ loadingâ€¦';

  // Fetch translation if missing
  if (!w.translation) {
    try {
      var cfg = getLangConfig();
      var gp = 'client=gtx&sl=' + cfg.translateFrom + '&tl=' + cfg.translateTo + '&dt=t&q=' + encodeURIComponent(w.word);
      var gr = await fetchWithTimeout('https://translate.googleapis.com/translate_a/single?' + gp, {}, 4000);
      var gd = await gr.json();
      var trans = '';
      if (gd && gd[0]) { for (var gi = 0; gi < gd[0].length; gi++) { if (gd[0][gi] && gd[0][gi][0]) trans += gd[0][gi][0]; } }
      if (trans) {
        w.translation = trans;
        await dbPut('words', w);
        wordCache.set(w.wordLower, w);
        document.getElementById('detailTrans').textContent = trans;
      } else {
        document.getElementById('detailTrans').textContent = 'â€”';
      }
    } catch (e) {
      document.getElementById('detailTrans').textContent = '(offline)';
    }
  }

  // Dictionary link
  var detailDictEl = document.getElementById('detailDict');
  if (currentLang === 'ru') {
    detailDictEl.innerHTML = '<a href="https://en.openrussian.org/ru/' + encodeURIComponent(w.word) + '" target="_blank" rel="noopener" style="color:var(--accent);font-size:12px;text-decoration:none;display:inline-flex;align-items:center;gap:4px;padding:6px 10px;background:var(--accent-dim);border-radius:8px;">ğŸ“– OpenRussian â€” base form, accent, declension</a>';
  } else {
    detailDictEl.innerHTML = '<a href="https://en.wiktionary.org/wiki/' + encodeURIComponent(w.word) + '" target="_blank" rel="noopener" style="color:var(--accent);font-size:12px;text-decoration:none;display:inline-flex;align-items:center;gap:4px;padding:6px 10px;background:var(--accent-dim);border-radius:8px;">ğŸ“– Wiktionary â€” full entry</a>';
  }

  const statusLabel = { new: 'New', saved: 'Saved', learning: 'Learning', known: 'Known', ignored: 'Ignored' };
  document.getElementById('detailMeta').innerHTML = `
    <span class="detail-badge b-status">${statusLabel[w.status] || w.status}</span>
    <span class="detail-badge b-encounters">${w.encounters || 1} encounter${(w.encounters||1) > 1 ? 's' : ''}</span>
  `;

  const ctxHtml = (w.contexts || []).map(c => `<div class="detail-ctx-item">Â« ${escHtml(c)} Â»</div>`).join('');
  document.getElementById('detailContexts').innerHTML = ctxHtml || '<div style="color:var(--muted);font-size:13px;">No context saved</div>';

  document.getElementById('detailKnown').onclick = async () => {
    w.status = 'known';
    await dbPut('words', w);
    wordCache.set(w.wordLower, w);
    recolorWords();
    closeModal('detailModal');
    renderVocabList();
    showToast('âœ“ Marked as known');
  };

  document.getElementById('detailDelete').onclick = async () => {
    if (confirm('Delete "' + w.word + '" from vocabulary?')) {
      await dbDelete('words', w.id);
      wordCache.delete(w.wordLower);
      recolorWords();
      closeModal('detailModal');
      renderVocabList();
      showToast('ğŸ—‘ Deleted');
    }
  };

  openModal('detailModal');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ Level System â”€â”€
var LEVELS = [
  { min: 0,     name: 'Beginner',        emoji: 'ğŸŒ±' },
  { min: 1000,  name: 'Novice',          emoji: 'ğŸ“—' },
  { min: 2000,  name: 'Apprentice',      emoji: 'ğŸ“˜' },
  { min: 5000,  name: 'Intermediate',    emoji: 'âš¡' },
  { min: 10000, name: 'Advanced',        emoji: 'ğŸ”¥' },
  { min: 20000, name: 'Proficient',      emoji: 'ğŸ’' },
  { min: 30000, name: 'Expert',          emoji: 'ğŸ…' },
  { min: 50000, name: 'Master',          emoji: 'ğŸ‘‘' },
  { min: 70000, name: 'Virtuoso',        emoji: 'ğŸŒŸ' },
  { min: 90000, name: 'Legend',          emoji: 'ğŸ†' }
];

function getLevelInfo(knownCount) {
  var lvl = 0;
  for (var i = LEVELS.length - 1; i >= 0; i--) {
    if (knownCount >= LEVELS[i].min) { lvl = i; break; }
  }
  var current = LEVELS[lvl];
  var next = LEVELS[lvl + 1] || null;
  var progress = 0;
  var xpText = '';

  if (next) {
    var range = next.min - current.min;
    var inRange = knownCount - current.min;
    progress = Math.min((inRange / range) * 100, 100);
    xpText = knownCount.toLocaleString() + ' / ' + next.min.toLocaleString() + ' known words';
  } else {
    progress = 100;
    xpText = knownCount.toLocaleString() + ' known words Â· MAX';
  }

  return {
    level: lvl + 1,
    name: current.name,
    emoji: current.emoji,
    progress: progress,
    xpText: xpText
  };
}

function renderLevel(knownCount) {
  var info = getLevelInfo(knownCount);
  document.getElementById('levelBadge').textContent = info.emoji;
  document.getElementById('levelTitle').textContent = info.name;
  document.getElementById('levelSubtitle').textContent = 'Level ' + info.level;
  document.getElementById('levelXpFill').style.width = info.progress + '%';
  document.getElementById('levelXpText').textContent = info.xpText;

  // Color gradient based on level
  var colors = ['#e94560','#e94560','#3b82f6','#3b82f6','#f59e0b','#f59e0b','#10b981','#10b981','#8b5cf6','#ffd700'];
  var c = colors[info.level - 1] || '#e94560';
  document.getElementById('levelBadge').style.background = 'linear-gradient(135deg, ' + c + ', ' + c + '44)';
  document.getElementById('levelBadge').style.boxShadow = '0 4px 20px ' + c + '40';
}

async function renderStats() {
  const words = await dbGetAll('words');
  const total = words.length;
  const newW = words.filter(w => w.status === 'new').length;
  const learning = words.filter(w => w.status === 'saved' || w.status === 'learning').length;
  const known = words.filter(w => w.status === 'known').length;

  // Render level
  renderLevel(known + learning);

  document.getElementById('statTotal').textContent = total;
  document.getElementById('statNew').textContent = newW;
  document.getElementById('statLearning').textContent = learning;
  document.getElementById('statKnown').textContent = known;

  // Progress bar
  if (total > 0) {
    document.getElementById('prgNew').style.width = (newW / total * 100) + '%';
    document.getElementById('prgLearning').style.width = (learning / total * 100) + '%';
    document.getElementById('prgKnown').style.width = (known / total * 100) + '%';
  }

  // Activity: group by date
  const byDate = {};
  for (const w of words) {
    const d = (w.createdAt || '').substring(0, 10);
    if (d) byDate[d] = (byDate[d] || 0) + 1;
  }
  const dates = Object.entries(byDate).sort((a, b) => b[0].localeCompare(a[0])).slice(0, 14);
  const actEl = document.getElementById('activityList');

  if (dates.length === 0) {
    actEl.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px;">No activity yet</div>';
    return;
  }

  actEl.innerHTML = dates.map(([date, count]) => `
    <div style="display:flex;align-items:center;gap:10px;padding:8px 12px;background:var(--surface);border-radius:10px;">
      <span style="font-family:'JetBrains Mono';font-size:12px;color:var(--muted);min-width:80px;">${date}</span>
      <div style="flex:1;height:6px;background:var(--surface2);border-radius:3px;overflow:hidden;">
        <div style="width:${Math.min(count * 5, 100)}%;height:100%;background:var(--accent);border-radius:3px;"></div>
      </div>
      <span style="font-family:'JetBrains Mono';font-size:13px;font-weight:600;color:var(--accent);min-width:24px;text-align:right;">+${count}</span>
    </div>
  `).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT / IMPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('btnExport').addEventListener('click', async () => {
  const words = await dbGetAll('words');
  const data = { version: 1, exportedAt: new Date().toISOString(), words };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `langvault-${currentLang || 'export'}-${new Date().toISOString().substring(0, 10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
  showToast('ğŸ“¤ Exported!');
});

document.getElementById('btnImport').addEventListener('click', () => {
  document.getElementById('importDbInput').click();
});

document.getElementById('importDbInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  try {
    const text = await file.text();
    const data = JSON.parse(text);
    const words = data.words || data;

    if (!Array.isArray(words)) {
      showToast('âŒ Invalid file format');
      return;
    }

    let imported = 0;
    for (const w of words) {
      const lower = (w.wordLower || w.word || '').toLowerCase();
      if (!lower) continue;

      const existing = wordCache.get(lower);
      if (existing) {
        // Merge: keep higher encounter count, merge contexts
        existing.encounters = Math.max(existing.encounters || 1, w.encounters || 1);
        if (w.translation && !existing.translation) existing.translation = w.translation;
        if (w.contexts) {
          existing.contexts = existing.contexts || [];
          for (const c of w.contexts) {
            if (!existing.contexts.includes(c) && existing.contexts.length < 10) {
              existing.contexts.push(c);
            }
          }
        }
        await dbPut('words', existing);
      } else {
        const entry = {
          word: w.word || lower,
          wordLower: lower,
          translation: w.translation || '',
          status: w.status || 'new',
          encounters: w.encounters || 1,
          contexts: w.contexts || [],
          createdAt: w.createdAt || new Date().toISOString(),
          lastSeen: w.lastSeen || new Date().toISOString()
        };
        await dbAdd('words', entry);
        imported++;
      }
    }

    await loadWordCache();
    showToast(`ğŸ“¥ Imported ${imported} new words!`);
    recolorWords();
  } catch (err) {
    showToast('âŒ Import error: ' + err.message);
  }
  e.target.value = '';
});

document.getElementById('btnClear').addEventListener('click', async () => {
  if (!confirm('Delete ALL vocabulary data? This cannot be undone.')) return;
  if (!confirm('Are you really sure?')) return;
  await dbClear('words');
  await dbClear('sources');
  wordCache.clear();
  recolorWords();
  showToast('ğŸ—‘ All data cleared');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODALS & TOAST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function openModal(id) {
  const el = document.getElementById(id);
  el.classList.add('show');
  el.addEventListener('click', (e) => {
    if (e.target === el) closeModal(id);
  }, { once: true });
}

// make closeModal global for inline onclick
window.closeModal = function(id) {
  document.getElementById(id).classList.remove('show');
};

let toastTimer;
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.classList.remove('show'), 2200);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UTILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VERCEL BACKEND URL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(function() {
  var input = document.getElementById('vercelUrlInput');
  if (!input) return;
  var saved = localStorage.getItem('rusvault_vercel_url') || '';
  if (saved) input.value = saved;

  document.getElementById('btnSaveVercel').addEventListener('click', function() {
    var url = input.value.trim();
    if (url && !url.startsWith('https://')) {
      showToast('âŒ L\'URL doit commencer par https://');
      return;
    }
    if (url) {
      localStorage.setItem('rusvault_vercel_url', url);
      showToast('âœ“ Vercel URL saved !');
    } else {
      localStorage.removeItem('rusvault_vercel_url');
      showToast('Vercel URL removed');
    }
  });
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FLASHCARD MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Toggle list vs flashcard
document.getElementById('btnVocabList').addEventListener('click', function() {
  this.classList.add('active');
  document.getElementById('btnVocabFlash').classList.remove('active');
  document.getElementById('vocabListMode').style.display = '';
  document.getElementById('vocabFlashMode').style.display = 'none';
});

document.getElementById('btnVocabFlash').addEventListener('click', function() {
  this.classList.add('active');
  document.getElementById('btnVocabList').classList.remove('active');
  document.getElementById('vocabListMode').style.display = 'none';
  document.getElementById('vocabFlashMode').style.display = '';
  populateFlashcardSetup();
});

// --- Chip selection helpers ---
function setupChipGroup(containerId, callback) {
  var container = document.getElementById(containerId);
  if (!container) return;
  container.addEventListener('click', function(e) {
    var chip = e.target.closest('.fc-chip');
    if (!chip) return;
    container.querySelectorAll('.fc-chip').forEach(function(c) { c.classList.remove('active'); });
    chip.classList.add('active');
    if (callback) callback();
  });
}

setupChipGroup('fcLessonChips', updateFcWordCount);
setupChipGroup('fcCountChips', updateFcWordCount);

async function populateFlashcardSetup() {
  var container = document.getElementById('fcLessonChips');
  // Keep "all" and "due" chips, add lesson-specific chips
  var lessons = await dbGetAll('lessons');
  // Remove old lesson chips
  container.querySelectorAll('[data-lesson-id]').forEach(function(c) { c.remove(); });

  for (var i = 0; i < lessons.length; i++) {
    var btn = document.createElement('button');
    btn.className = 'fc-chip';
    btn.dataset.lessonId = lessons[i].id;
    btn.dataset.lesson = 'lesson-' + lessons[i].id;
    btn.textContent = lessons[i].title.length > 18 ? lessons[i].title.substring(0, 18) + 'â€¦' : lessons[i].title;
    container.appendChild(btn);
  }
  updateFcWordCount();
}

async function getFcCandidateWords() {
  var activeChip = document.querySelector('#fcLessonChips .fc-chip.active');
  var lessonFilter = activeChip ? activeChip.dataset.lesson : 'all';

  var allWords = await dbGetAll('words');
  var candidates = [];

  if (lessonFilter === 'all') {
    candidates = allWords.filter(function(w) {
      return w.status !== 'ignored' && w.status !== 'new';
    });
  } else if (lessonFilter === 'saved') {
    candidates = allWords.filter(function(w) {
      return w.status === 'saved' || w.status === 'learning';
    });
  } else if (lessonFilter === 'known') {
    candidates = allWords.filter(function(w) {
      return w.status === 'known';
    });
  } else if (lessonFilter === 'due') {
    var now = Date.now();
    candidates = allWords.filter(function(w) {
      if (w.status === 'ignored' || w.status === 'new') return false;
      if (!w.nextReview) return (w.status === 'saved' || w.status === 'learning');
      return new Date(w.nextReview).getTime() <= now;
    });
  } else {
    // Specific lesson
    var lessonId = parseInt(activeChip.dataset.lessonId);
    var lesson = await dbGet('lessons', lessonId);
    if (lesson) {
      var lessonWords = {};
      var matches = lesson.text.match(WORD_REGEX) || [];
      for (var m = 0; m < matches.length; m++) {
        lessonWords[matches[m].toLowerCase()] = true;
      }
      candidates = allWords.filter(function(w) {
        return lessonWords[w.wordLower || w.word] && w.status !== 'ignored' && w.status !== 'new';
      });
    }
  }

  return candidates;
}

function updateFcWordCount() {
  getFcCandidateWords().then(function(candidates) {
    var countChip = document.querySelector('#fcCountChips .fc-chip.active');
    var maxCount = countChip ? countChip.dataset.count : '20';
    var total = candidates.length;
    var actual = maxCount === 'all' ? total : Math.min(parseInt(maxCount), total);

    var msg = '';
    if (total === 0) {
      msg = 'âš ï¸ No words available. Save words while reading to review them here!';
    } else {
      msg = actual + ' card' + (actual > 1 ? 's' : '') + ' available out of ' + total;
    }
    document.getElementById('fcWordCount').textContent = msg;
    document.getElementById('fcStartBtn').disabled = (actual === 0);
  });
}

// --- SRS Algorithm (SM-2 inspired, hidden from user) ---
function srsSchedule(word, grade) {
  // grade: 0=again, 1=hard, 2=good, 3=easy
  var interval = word.srsInterval || 0;  // in minutes
  var ease = word.srsEase || 2.5;
  var reps = word.srsReps || 0;
  var now = new Date();

  if (grade === 0) {
    // Again â€” reset, show again in 1 minute
    interval = 1;
    reps = 0;
    ease = Math.max(1.3, ease - 0.2);
  } else if (grade === 1) {
    // Hard
    if (reps === 0) { interval = 10; }
    else if (reps === 1) { interval = 60 * 24; }     // 1 day
    else { interval = interval * 1.2; }
    ease = Math.max(1.3, ease - 0.15);
    reps++;
  } else if (grade === 2) {
    // Good
    if (reps === 0) { interval = 60 * 24; }          // 1 day
    else if (reps === 1) { interval = 60 * 24 * 3; }  // 3 days
    else { interval = interval * ease; }
    reps++;
  } else if (grade === 3) {
    // Easy
    if (reps === 0) { interval = 60 * 24 * 3; }      // 3 days
    else if (reps === 1) { interval = 60 * 24 * 7; }  // 7 days
    else { interval = interval * ease * 1.3; }
    ease += 0.15;
    reps++;
  }

  var nextReview = new Date(now.getTime() + interval * 60 * 1000);

  // Determine if word is now "known"
  var newStatus = word.status;
  if (interval >= 60 * 24 * 21) {
    // 21+ days interval = considered known
    newStatus = 'known';
  } else {
    newStatus = 'learning';
  }

  return {
    srsInterval: Math.round(interval),
    srsEase: Math.round(ease * 100) / 100,
    srsReps: reps,
    nextReview: nextReview.toISOString(),
    status: newStatus
  };
}

function formatInterval(minutes) {
  if (minutes < 60) return Math.round(minutes) + 'm';
  if (minutes < 60 * 24) return Math.round(minutes / 60) + 'h';
  return Math.round(minutes / (60 * 24)) + 'j';
}

// --- Flashcard Session ---
var fcDeck = [];
var fcIndex = 0;
var fcRevealed = false;
var fcResults = { again: 0, hard: 0, good: 0, easy: 0 };

document.getElementById('fcStartBtn').addEventListener('click', async function() {
  var candidates = await getFcCandidateWords();
  if (candidates.length === 0) { showToast('No words to review'); return; }

  var countChip = document.querySelector('#fcCountChips .fc-chip.active');
  var maxCount = countChip ? countChip.dataset.count : '20';
  var max = maxCount === 'all' ? candidates.length : parseInt(maxCount);

  // Shuffle
  for (var s = candidates.length - 1; s > 0; s--) {
    var r = Math.floor(Math.random() * (s + 1));
    var tmp = candidates[s]; candidates[s] = candidates[r]; candidates[r] = tmp;
  }

  // Prioritize: due items first, then by least seen
  candidates.sort(function(a, b) {
    var aDue = (!a.nextReview || new Date(a.nextReview).getTime() <= Date.now()) ? 0 : 1;
    var bDue = (!b.nextReview || new Date(b.nextReview).getTime() <= Date.now()) ? 0 : 1;
    if (aDue !== bDue) return aDue - bDue;
    return (a.srsReps || 0) - (b.srsReps || 0);
  });

  fcDeck = candidates.slice(0, max);
  fcIndex = 0;
  fcRevealed = false;
  fcResults = { again: 0, hard: 0, good: 0, easy: 0 };

  document.getElementById('fcSession').classList.add('active');
  showFcCard();
});

function showFcCard() {
  if (fcIndex >= fcDeck.length) {
    showFcResults();
    return;
  }

  var word = fcDeck[fcIndex];
  fcRevealed = false;

  document.getElementById('fcWord').textContent = word.word || word.wordLower;
  document.getElementById('fcHint').style.display = '';
  document.getElementById('fcAnswer').style.display = 'none';
  document.getElementById('fcCtx').style.display = 'none';
  document.getElementById('fcButtons').style.display = 'none';

  // Update progress
  document.getElementById('fcProgressText').textContent = (fcIndex + 1) + ' / ' + fcDeck.length;
  var pct = ((fcIndex) / fcDeck.length) * 100;
  document.getElementById('fcProgressFill').style.width = pct + '%';

  // Preview intervals for buttons
  var simulHard = srsSchedule(word, 1);
  var simulGood = srsSchedule(word, 2);
  var simulEasy = srsSchedule(word, 3);
  document.getElementById('fcHardInt').textContent = formatInterval(simulHard.srsInterval);
  document.getElementById('fcGoodInt').textContent = formatInterval(simulGood.srsInterval);
  document.getElementById('fcEasyInt').textContent = formatInterval(simulEasy.srsInterval);

  // Auto-speak
  speakWord(word.word || word.wordLower);
}

// Reveal on card tap
document.getElementById('fcCard').addEventListener('click', async function() {
  if (fcRevealed || fcIndex >= fcDeck.length) return;
  fcRevealed = true;

  var word = fcDeck[fcIndex];
  document.getElementById('fcHint').style.display = 'none';
  document.getElementById('fcAnswer').style.display = '';

  if (word.translation) {
    document.getElementById('fcAnswer').textContent = word.translation;
  } else {
    document.getElementById('fcAnswer').textContent = 'â³ loadingâ€¦';
    try {
      var cfg = getLangConfig();
      var gp = 'client=gtx&sl=' + cfg.translateFrom + '&tl=' + cfg.translateTo + '&dt=t&q=' + encodeURIComponent(word.word || word.wordLower);
      var gr = await fetchWithTimeout('https://translate.googleapis.com/translate_a/single?' + gp, {}, 4000);
      var gd = await gr.json();
      var trans = '';
      if (gd && gd[0]) { for (var gi = 0; gi < gd[0].length; gi++) { if (gd[0][gi] && gd[0][gi][0]) trans += gd[0][gi][0]; } }
      word.translation = trans || 'â€”';
      document.getElementById('fcAnswer').textContent = word.translation;
      await dbPut('words', word);
      wordCache.set(word.wordLower || word.word, word);
    } catch (e) {
      document.getElementById('fcAnswer').textContent = '(offline)';
    }
  }

  if (word.contexts && word.contexts.length > 0) {
    document.getElementById('fcCtx').style.display = '';
    document.getElementById('fcCtx').textContent = 'Â« ' + word.contexts[0].substring(0, 120) + ' Â»';
  }

  document.getElementById('fcButtons').style.display = '';
});

// Speak button
document.getElementById('fcSpeak').addEventListener('click', function(e) {
  e.stopPropagation();
  if (fcIndex < fcDeck.length) {
    var word = fcDeck[fcIndex];
    speakWord(word.word || word.wordLower);
  }
});

// Grade buttons
document.getElementById('fcButtons').addEventListener('click', async function(e) {
  var btn = e.target.closest('.fc-btn');
  if (!btn) return;
  var grade = parseInt(btn.dataset.grade);

  var word = fcDeck[fcIndex];
  var srs = srsSchedule(word, grade);

  // Update word in DB
  word.srsInterval = srs.srsInterval;
  word.srsEase = srs.srsEase;
  word.srsReps = srs.srsReps;
  word.nextReview = srs.nextReview;
  word.status = srs.status;
  word.lastSeen = new Date().toISOString();

  await dbPut('words', word);
  wordCache.set(word.wordLower || word.word, word);

  // Track results
  if (grade === 0) fcResults.again++;
  else if (grade === 1) fcResults.hard++;
  else if (grade === 2) fcResults.good++;
  else fcResults.easy++;

  // If "again", put card back in deck a few positions later
  if (grade === 0) {
    var reinsertAt = Math.min(fcIndex + 3 + Math.floor(Math.random() * 3), fcDeck.length);
    fcDeck.splice(reinsertAt, 0, word);
  }

  fcIndex++;
  showFcCard();
});

function showFcResults() {
  var total = fcResults.again + fcResults.hard + fcResults.good + fcResults.easy;
  var successRate = total > 0 ? Math.round(((fcResults.good + fcResults.easy) / total) * 100) : 0;

  var emoji = successRate >= 80 ? 'ğŸ†' : successRate >= 50 ? 'ğŸ’ª' : 'ğŸ“–';

  document.getElementById('fcCardArea').innerHTML =
    '<div class="fc-result">' +
      '<div class="fc-result-big">' + emoji + '</div>' +
      '<div class="fc-result-text">' + successRate + '% success rate</div>' +
      '<div class="fc-result-sub">' +
        'âŒ ' + fcResults.again + '  Â·  ğŸŸ¡ ' + fcResults.hard + '  Â·  âœ… ' + fcResults.good + '  Â·  â­ ' + fcResults.easy +
      '</div>' +
    '</div>';

  document.getElementById('fcButtons').style.display = 'none';
  document.getElementById('fcProgressFill').style.width = '100%';
  document.getElementById('fcProgressText').textContent = 'Done!';
}

// Close flashcard session
document.getElementById('fcCloseBtn').addEventListener('click', function() {
  document.getElementById('fcSession').classList.remove('active');
  // Reset card area HTML for next session
  document.getElementById('fcCardArea').innerHTML =
    '<div class="fc-card" id="fcCard">' +
      '<div class="fc-card-word" id="fcWord">â€”</div>' +
      '<button class="fc-speak-btn" id="fcSpeak">ğŸ”Š</button>' +
      '<div class="fc-card-hint" id="fcHint">Tap to reveal</div>' +
      '<div class="fc-card-answer" id="fcAnswer" style="display:none;">â€”</div>' +
      '<div class="fc-card-ctx" id="fcCtx" style="display:none;"></div>' +
    '</div>';

  // Re-bind card and speak events
  document.getElementById('fcCard').addEventListener('click', function() {
    if (fcRevealed || fcIndex >= fcDeck.length) return;
    fcRevealed = true;
    var word = fcDeck[fcIndex];
    document.getElementById('fcHint').style.display = 'none';
    document.getElementById('fcAnswer').style.display = '';
    document.getElementById('fcAnswer').textContent = word.translation || '(no translation)';
    if (word.contexts && word.contexts.length > 0) {
      document.getElementById('fcCtx').style.display = '';
      document.getElementById('fcCtx').textContent = 'Â« ' + word.contexts[0].substring(0, 120) + ' Â»';
    }
    document.getElementById('fcButtons').style.display = '';
  });
  document.getElementById('fcSpeak').addEventListener('click', function(e) {
    e.stopPropagation();
    if (fcIndex < fcDeck.length) speakWord(fcDeck[fcIndex].word || fcDeck[fcIndex].wordLower);
  });

  renderVocabList();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LANGUAGE SELECTION & NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showHome() {
  // Show home, hide app views
  document.querySelectorAll('.view').forEach(function(v) { v.classList.remove('active'); });
  document.getElementById('viewHome').classList.add('active');
  document.querySelector('.tab-bar').classList.add('hidden');
  document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
  document.getElementById('logoText').textContent = 'Lang';
}

async function selectLanguage(lang) {
  currentLang = lang;
  var cfg = getLangConfig();

  // Set dynamic word patterns
  WORD_REGEX = cfg.wordRegex;
  WORD_TEST = cfg.wordTest;

  // Update DB name and reopen
  DB_NAME = cfg.dbName;
  db = null;
  wordCache = new Map();
  await openDB();
  await loadWordCache();

  // Update UI
  document.getElementById('logoText').textContent = cfg.flag + ' ';
  document.getElementById('importHeading').textContent = cfg.importLabel;

  // Save choice
  localStorage.setItem('lv_lang', lang);

  // Reset reader state
  currentLessonId = null;
  allChunks = [];
  pages = [];
  currentPage = 0;
  document.getElementById('importArea').style.display = '';
  document.getElementById('readerContent').classList.remove('has-text');

  // Preload voices for this language
  cachedVoice = null;
  preloadVoices();

  // Show app
  document.querySelector('.tab-bar').classList.remove('hidden');
  document.querySelectorAll('.view').forEach(function(v) { v.classList.remove('active'); });
  document.getElementById('viewReader').classList.add('active');
  document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
  document.querySelector('.tab[data-view="viewReader"]').classList.add('active');

  // Refresh
  renderLessonList();
  console.log('[LangVault] ' + cfg.name + ' ready. ' + wordCache.size + ' words cached.');
}

// Language card clicks
document.querySelectorAll('.lang-card').forEach(function(card) {
  card.addEventListener('click', function() {
    selectLanguage(card.dataset.lang);
  });
});

// Logo click â†’ back to home
document.getElementById('logoBtn').addEventListener('click', function() {
  showHome();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function init() {
  loadSettings();

  var savedLang = localStorage.getItem('lv_lang');
  if (savedLang && LANG_CONFIG[savedLang]) {
    await selectLanguage(savedLang);
  } else {
    showHome();
  }
}

init().catch(function(err) { console.error('[RusVault] Init error:', err); });

// Service Worker â€” force update
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(function(regs) {
    regs.forEach(function(reg) { reg.update(); });
  });
  navigator.serviceWorker.register('sw.js').catch(function() {});
}

// Reset SW button
document.getElementById('btnResetSW').addEventListener('click', async function() {
  if (!('serviceWorker' in navigator)) { showToast('No Service Worker'); return; }
  try {
    var regs = await navigator.serviceWorker.getRegistrations();
    for (var i = 0; i < regs.length; i++) {
      await regs[i].unregister();
    }
    var keys = await caches.keys();
    for (var j = 0; j < keys.length; j++) {
      await caches.delete(keys[j]);
    }
    showToast('âœ“ Reset OK ! Reloadingâ€¦');
    setTimeout(function() { window.location.reload(); }, 1000);
  } catch (e) {
    showToast('Error: ' + e.message);
  }
});

})();
</script>
</body>
</html>
